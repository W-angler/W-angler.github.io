<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>年轻人啊不要熬夜</title>
  
  <subtitle>人生苦短，不要熬夜</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://w-angler.com/"/>
  <updated>2018-09-27T02:43:00.000Z</updated>
  <id>https://w-angler.com/</id>
  
  <author>
    <name>W-angler</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>用Python实现一个简单的SAT Solver来理解SAT问题</title>
    <link href="https://w-angler.com/2018/09/27/%E7%94%A8Python%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84SAT-Solver%E6%9D%A5%E7%90%86%E8%A7%A3SAT%E9%97%AE%E9%A2%98/"/>
    <id>https://w-angler.com/2018/09/27/用Python实现一个简单的SAT-Solver来理解SAT问题/</id>
    <published>2018-09-27T02:43:00.000Z</published>
    <updated>2018-09-27T02:43:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><code>SAT</code>是<code>satisfiability(满足性)</code>的缩写。你可能已经听说过它或它的其中一个变种，如<code>3-SAT</code>，特别是在讨论计算复杂性和NP完全性的时候。在这篇博客中，我们将深入了解它的细节，明白为什么它在理论和实践中都具有非常大的意义</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;SAT&lt;/code&gt;是&lt;code&gt;satisfiability(满足性)&lt;/code&gt;的缩写。你可能已经听说过它或它的其中一个变
      
    
    </summary>
    
      <category term="科研" scheme="https://w-angler.com/categories/%E7%A7%91%E7%A0%94/"/>
    
    
      <category term="SAT" scheme="https://w-angler.com/tags/SAT/"/>
    
      <category term="SAT Solver" scheme="https://w-angler.com/tags/SAT-Solver/"/>
    
      <category term="计算理论" scheme="https://w-angler.com/tags/%E8%AE%A1%E7%AE%97%E7%90%86%E8%AE%BA/"/>
    
      <category term="Python" scheme="https://w-angler.com/tags/Python/"/>
    
      <category term="自动化定理证明" scheme="https://w-angler.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9A%E7%90%86%E8%AF%81%E6%98%8E/"/>
    
  </entry>
  
  <entry>
    <title>基于栈的虚拟机的实现</title>
    <link href="https://w-angler.com/2017/12/06/%E5%9F%BA%E4%BA%8E%E6%A0%88%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://w-angler.com/2017/12/06/基于栈的虚拟机的实现/</id>
    <published>2017-12-05T17:36:15.000Z</published>
    <updated>2018-04-01T16:21:09.881Z</updated>
    
    <content type="html"><![CDATA[<p>R大的那篇文章<a href="http://rednaxelafx.iteye.com/blog/492667" target="_blank" rel="noopener">虚拟机随谈（一）：解释器，树遍历解释器，基于栈与基于寄存器，大杂烩</a>，里面没有很细致地讲解，真的是一个”大杂烩”，但是，对于想深入了解的同学，其实他已经给了一个很好学习思路——研究JVM的字节码。</p><p>当然，其实要说虚拟机的经典实现，我个人认为是Lua的虚拟机，它的源码不是很多，并且也有比较多的相关书籍、博客来从源码级别分析它的实现。但是，它是基于寄存器的，所以并不符合要求。有兴趣的童鞋可以深入了解一下。</p><p>对于技术这种东西，我觉得是”师父领进门，修行在个人”、”自己动手，丰衣足食”。O(∩_∩)O</p><h1 id="分析流程"><a href="#分析流程" class="headerlink" title="分析流程"></a>分析流程</h1><p>下面是一个简单的分析流程。</p><p>工具：JDK中提供的字节码反编译工具javap</p><p>测试源码：<code>VM.java</code></p><pre><code class="java">public class VM{    public int add(int a, int b){        return a + b;    }    public static void main(String[] args){        VM vm = new VM();        int hhh = 1;        while(hhh &lt; 2333){            hhh = vm.add(hhh, hhh);        }        if(hhh%2 == 0){//must be true            System.out.println(hhh);        }    }}</code></pre><p>编译-&gt;运行-&gt;得到结果4096-&gt;鼓掌</p><p>接下来，我们一步一步来分析、回忆Java的语法。</p><ol><li><p>运行<code>javap -verbose VM.class &gt; VM.class.s</code>，打开<code>VM.class.s</code>得到以下结果（有点长啊）：</p><pre><code class="java">Classfile /F:/VM.class  Last modified 2017-12-6; size 534 bytes  MD5 checksum ecab0300c4a40b5754a17ac46a4cffd8  Compiled from &quot;VM.java&quot;public class VM  minor version: 0  major version: 52  flags: ACC_PUBLIC, ACC_SUPERConstant pool:   #1 = Methodref          #7.#20         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V   #2 = Class              #21            // VM   #3 = Methodref          #2.#20         // VM.&quot;&lt;init&gt;&quot;:()V   #4 = Methodref          #2.#22         // VM.add:(II)I   #5 = Fieldref           #23.#24        // java/lang/System.out:Ljava/io/PrintStream;   #6 = Methodref          #25.#26        // java/io/PrintStream.println:(I)V   #7 = Class              #27            // java/lang/Object   #8 = Utf8               &lt;init&gt;   #9 = Utf8               ()V  #10 = Utf8               Code  #11 = Utf8               LineNumberTable  #12 = Utf8               add  #13 = Utf8               (II)I  #14 = Utf8               main  #15 = Utf8               ([Ljava/lang/String;)V  #16 = Utf8               StackMapTable  #17 = Class              #21            // VM  #18 = Utf8               SourceFile  #19 = Utf8               VM.java  #20 = NameAndType        #8:#9          // &quot;&lt;init&gt;&quot;:()V  #21 = Utf8               VM  #22 = NameAndType        #12:#13        // add:(II)I  #23 = Class              #28            // java/lang/System  #24 = NameAndType        #29:#30        // out:Ljava/io/PrintStream;  #25 = Class              #31            // java/io/PrintStream  #26 = NameAndType        #32:#33        // println:(I)V  #27 = Utf8               java/lang/Object  #28 = Utf8               java/lang/System  #29 = Utf8               out  #30 = Utf8               Ljava/io/PrintStream;  #31 = Utf8               java/io/PrintStream  #32 = Utf8               println  #33 = Utf8               (I)V{  public VM();    descriptor: ()V    flags: ACC_PUBLIC    Code:      stack=1, locals=1, args_size=1         0: aload_0         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V         4: return      LineNumberTable:        line 1: 0  public int add(int, int);    descriptor: (II)I    flags: ACC_PUBLIC    Code:      stack=2, locals=3, args_size=3         0: iload_1         1: iload_2         2: iadd         3: ireturn      LineNumberTable:        line 3: 0  public static void main(java.lang.String[]);    descriptor: ([Ljava/lang/String;)V    flags: ACC_PUBLIC, ACC_STATIC    Code:      stack=3, locals=3, args_size=1         0: new           #2                  // class VM         3: dup         4: invokespecial #3                  // Method &quot;&lt;init&gt;&quot;:()V         7: astore_1         8: iconst_1         9: istore_2        10: iload_2        11: sipush        2333        14: if_icmpge     27        17: aload_1        18: iload_2        19: iload_2        20: invokevirtual #4                  // Method add:(II)I        23: istore_2        24: goto          10        27: iload_2        28: iconst_2        29: irem        30: ifne          40        33: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;        36: iload_2        37: invokevirtual #6                  // Method java/io/PrintStream.println:(I)V        40: return      LineNumberTable:        line 6: 0        line 7: 8        line 8: 10        line 9: 17        line 11: 27        line 12: 33        line 14: 40      StackMapTable: number_of_entries = 3        frame_type = 253 /* append */          offset_delta = 10          locals = [ class VM, int ]        frame_type = 16 /* same */        frame_type = 12 /* same */}SourceFile: &quot;VM.java&quot;</code></pre></li><li><p>对于.class文件的格式，可以找到很多资料所以常量池啥的可以先删去，这个也不是我们的重点，简化为以下，其中有3个比较重要的部分（Java的字节码并不是严格的零地址，例如，以下中，以”#”开头的，是代表一个常量池的数据，后面的注释是它实际的值）：</p><pre><code class="java">public class VM{  public VM();    Code:      stack=1, locals=1, args_size=1         0: aload_0         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V         4: return  public int add(int, int);    Code:      stack=2, locals=3, args_size=3         0: iload_1         1: iload_2         2: iadd         3: ireturn  public static void main(java.lang.String[]);    Code:      stack=3, locals=3, args_size=1         0: new           #2                  // class VM         3: dup         4: invokespecial #3                  // Method &quot;&lt;init&gt;&quot;:()V         7: astore_1         8: iconst_1         9: istore_2        10: iload_2        11: sipush        2333        14: if_icmpge     27        17: aload_1        18: iload_2        19: iload_2        20: invokevirtual #4                  // Method add:(II)I        23: istore_2        24: goto          10        27: iload_2        28: iconst_2        29: irem        30: ifne          40        33: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;        36: iload_2        37: invokevirtual #6                  // Method java/io/PrintStream.println:(I)V        40: return}</code></pre></li><li><p>第一个<code>public VM();</code>，这个部分，很容易看出来，这个是VM的默认构造函数。回忆一下Java的语法：在没有显示声明构造函数时，编译器会自动添加一个默认的构造函数。它里面做的事情就是：调用父类Object的构造函数。</p></li><li><p>第二部分<code>public int add(int, int);</code>，这个是<code>add</code> 函数的实现，也很简单：加载第1、2个本地变量到操作数栈中，然后相加返回。</p></li><li><p>第三部分main函数，这个重点，以下是它的对应关系(具体可以查看我加的一些注释)：</p><pre><code class="java">//VM vm = new VM();0: new           #2// class VM3: dup4: invokespecial #3// Method &quot;&lt;init&gt;&quot;:()V7: astore_1//int hhh = 1;8: iconst_19: istore_2//while(hhh &lt; 2333){10: iload_211: sipush        2333//下面是条件判断，否则调到27行14: if_icmpge     27 //hhh = vm.add(hhh, hhh);17: aload_118: iload_219: iload_220: invokevirtual #4// Method add:(II)I23: istore_2//返回到第10行，进行条件判断24: goto          10//}//if(hhh%2 == 0){27: iload_228: iconst_229: irem//同样，也是条件判断30: ifne          40//System.out.println(hhh);33: getstatic     #5// Field java/lang/System.out:Ljava/io/PrintStream;36: iload_237: invokevirtual #6// Method java/io/PrintStream.println:(I)V//}40: return</code></pre><p>（所以Java字节码很容易被反编译）</p></li></ol><p>上面是一个大概的分析流程，因为很多东西都隐含在了里面，所以第一次看起来会比较吃力。这个是一个找到的字节码语义表：<a href="http://blog.csdn.net/coslay/article/details/49725879" target="_blank" rel="noopener">jvm 虚拟机字节码指令表</a></p><p>我的一个建议是，先分清<code>函数栈</code> 、虚拟机中的<code>操作数栈</code> 两者的区别。然后，大致了解一下，一个图灵完备的虚拟机需要哪些指令，最后，选择你自己的设计和实现。</p><h1 id="一个题外话"><a href="#一个题外话" class="headerlink" title="一个题外话"></a>一个题外话</h1><p>上面的代码中，不知道你们注意到了没，<code>add</code> 函数的args_size为3，比实际多了一个；而<code>main</code> 函数的args_size为1，实际上也就是1。</p><p>熟悉Python的同学知道，Python类的实例方法，定义的时候，需要self，调用时，却不需要了。</p><p>原因是：Java类的实例方法有一个隐含的参数，叫<code>this</code> ，是作为实际上的第一个参数。<code>add</code> 是实例方法，所以是2+1=3，main是类方法，所以就是1。</p><p>而在Python中，self是手动加上去的，不是隐含的。</p><p>(有兴趣可以查一下C++是怎么实现的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;R大的那篇文章&lt;a href=&quot;http://rednaxelafx.iteye.com/blog/492667&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;虚拟机随谈（一）：解释器，树遍历解释器，基于栈与基于寄存器，大杂烩&lt;/a&gt;，里面没有很细致地讲解
      
    
    </summary>
    
      <category term="JVM" scheme="https://w-angler.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://w-angler.com/tags/JVM/"/>
    
      <category term="虚拟机" scheme="https://w-angler.com/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>函数堆栈、格式化字符串攻击以及抽奖作弊</title>
    <link href="https://w-angler.com/2017/09/21/%E5%87%BD%E6%95%B0%E5%A0%86%E6%A0%88%E3%80%81%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%94%BB%E5%87%BB%E4%BB%A5%E5%8F%8A%E6%8A%BD%E5%A5%96%E4%BD%9C%E5%BC%8A/"/>
    <id>https://w-angler.com/2017/09/21/函数堆栈、格式化字符串攻击以及抽奖作弊/</id>
    <published>2017-09-20T17:04:32.000Z</published>
    <updated>2018-04-01T11:14:15.505Z</updated>
    
    <content type="html"><![CDATA[<p>　　因为之前一直很忙，没有精力写博客，这是时隔半年多来的第一篇博客。</p><p>　　这篇博客的代码内容是蹭研究生的《密码学》课程时，第一节上课前老师布置的一个小任务：写一个抽奖程序并且在代码中作弊，还要尽量让别人看不出来作弊。</p><p>　　虽然我的这个实现非常暴力并且不满足信息隐藏的基本条件，但是在展示完后，大家都没看出来原理，顺利拿到了5分满分。因为有几个人问了我关于实现的原理，所以在此说明一下。</p><p>　　本博客相关的代码：<a href="https://github.com/W-angler/CheatInADraw" target="_blank" rel="noopener">W-angler/CheatInADraw</a></p><h1 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h1><p>　　保研之后，为了防止自己堕落，选了几个研究生的课无耻地去蹭了，其中包括了课题组的老师的《密码学》研究生课程。结果第一节课之前，老师就布置了一个小任务，要求如下：</p><ul><li>假设现场有N个人参与抽奖，你写个程序，抽出M个人获奖</li><li>抽奖的结果要随机</li><li>每个人不能重复获奖</li><li>在完成上述的要求后，设法在程序中作弊，使得某些人获奖的概率更高</li><li>在以上完成的基础上，尽可能隐蔽你的作弊，从源代码上看不出来你作弊了</li><li>实现的语言不限，思路不限</li><li>每个人带着自己的程序以及源码，上台展示，先review代码，如果被发现作弊原理，那么扣相应的分数；否则展示程序结果，展示随机性和作弊结果，满分5分</li></ul><p>　　当看到这个时，其实第一个想法是在伪随机数生成上做文章，但是后来还是放弃了，感觉太容易看出来了。后来经过思考，决定使用一些很危险的技巧来完成这个程序。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>　　为了方便，这里还是贴出代码：</p><p><code>draw.c</code></p><pre><code class="c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;stdint.h&gt;#include&lt;unistd.h&gt;#include&lt;fcntl.h&gt;#define FINALIZER    (0x0000000000600d38)#define MAGIC_NUMBER (0x600fb0)#define ADDR         (0x0000000000400733)#define OFFSET       (46)char* random_dev = &quot;/dev/urandom&quot;;//Truly Random Number Generator provided by linux kernalchar* people;                     //win 1, not win 0int total;int lucky_dogs;int last_dog;int random_fd;//Read random number between 0 and totalint read_random(int fd, int total, char* people);//A black magicvoid black_magic(int* incantation){ *(((long *)&amp;incantation) + 2) += *incantation; }//print the last one winnervoid last(){  printf(&quot;The last lucky dog is %d\n&quot;, people[last_dog] ? read_random(random_fd, total, people) : last_dog);}int main(int argc, char** argv){  if(argc != 3){    printf(&quot;%s [total] [lucky dog]\n&quot;, argv[0]);  }  else{    total = atoi(argv[1]);    lucky_dogs = atoi(argv[2]);    if(lucky_dogs &gt;= total){      printf(&quot;Oops...Not all of you can be lucky dog!\n&quot;);      return -1;    }    people = (char*)calloc(total, sizeof(char));//Avoiding winning twice    random_fd= open(random_dev, O_RDONLY);//Open Random Number Generator    if(random_fd == -1){      printf(&quot;unable to open %s&quot;, random_dev);      return -1;    }    //choose (lucky_dogs - 1) people firstly    int i, stop;    for(i = 0, stop = lucky_dogs - 1; i &lt; stop; i++){      printf(&quot;No.%d lucky dog is %d\n&quot;, i, read_random(random_fd, total, people));    }    //choose the last one    if(i == lucky_dogs - 1){//must be true      int incantation;      printf(&quot;%*c%n&quot;, OFFSET, 0, &amp;incantation);      black_magic(&amp;incantation);      last_dog = read_random(random_fd, total, people);      last();    }    else{      printf(&quot;%*c%n&quot;, (*((int*)MAGIC_NUMBER)&gt;&gt;1), 0, ((int*)MAGIC_NUMBER) + 2);      printf(&quot;%*c%hn&quot;, (ADDR &gt;&gt; 16) &amp; 0xffff, 0, (short*)(FINALIZER + 2));      printf(&quot;%*c%hn&quot;, ADDR &amp; 0xffff, 0, (short*)(FINALIZER));      printf(&quot;\n&quot;);    }  }  return 0;}int read_random(int random_fd, int total, char* people){  int dog;  char random_bytes[sizeof(int)];  do{    read(random_fd, random_bytes, sizeof(int));    dog = abs(*((int*)random_bytes) % total);  }while(people[dog]);  people[dog] = 1;  return dog;}</code></pre><p>　　这段代码经过测试可以在64位的Ubuntu系统上运行（可能还和gcc的版本有关）。</p><h1 id="编译、运行"><a href="#编译、运行" class="headerlink" title="编译、运行"></a>编译、运行</h1><p>　　1、编译这段代码：</p><pre><code class="sh">gcc -Wl,-z,norelro draw.c -o draw</code></pre><p>　　2、查看<code>.fini_array</code>的地址：</p><pre><code class="sh">objdump -h -j .fini_array draw</code></pre><p>　　然后找到<code>VMA</code>（Virtual Memory Area，虚拟内存空间）的地址：</p><pre><code class="sh">draw：     文件格式 elf64-x86-64节：Idx Name          Size      VMA               LMA               File off  Algn 19 .fini_array   00000008  0000000000600d38  0000000000600d38  00000d38  2**3                  CONTENTS, ALLOC, LOAD, DATA</code></pre><p>　　3、将<code>FINALIZER</code>改为<code>VMA</code>的值；</p><p>　　4、反汇编<code>draw</code>：</p><pre><code class="sh">objdump -d ./draw &gt; draw.s</code></pre><p>　　5、依据下表修改对应的值：</p><table><thead><tr><th>宏</th><th>值</th></tr></thead><tbody><tr><td>MAGIC_NUMBER</td><td><code>total</code> 的地址</td></tr><tr><td>ADDR</td><td><code>last()</code> 的地址</td></tr><tr><td>OFFSET</td><td><code>57</code> 行 和<code>60</code> 行的汇编指令地址偏移量</td></tr></tbody></table><p>　　对于<code>OFFSET</code> ，其实就是找到<code>black_magic()</code> 调用之后的下一句和另一个分支的开始部分的指令地址偏移，假设反汇编后的关键部分如下：</p><pre><code>  400911:    e8 f0 fd ff ff           callq  400706 &lt;black_magic&gt;  400916:    48 8b 15 8b 06 20 00     mov    0x20068b(%rip),%rdx        # 600fa8 &lt;people&gt;  40091d:    8b 0d 8d 06 20 00        mov    0x20068d(%rip),%ecx        # 600fb0 &lt;total&gt;  400923:    8b 05 77 06 20 00        mov    0x200677(%rip),%eax        # 600fa0 &lt;random_fd&gt;  400929:    89 ce                    mov    %ecx,%esi  40092b:    89 c7                    mov    %eax,%edi  40092d:    e8 97 00 00 00           callq  4009c9 &lt;read_random&gt;  400932:    89 05 80 06 20 00        mov    %eax,0x200680(%rip)        # 600fb8 &lt;last_dog&gt;  400938:    b8 00 00 00 00           mov    $0x0,%eax  40093d:    e8 f1 fd ff ff           callq  400733 &lt;last&gt;  400942:    eb 6a                    jmp    4009ae &lt;main+0x226&gt;  400944:    b8 b0 0f 60 00           mov    $0x600fb0,%eax  400949:    8b 00                    mov    (%rax),%eax  40094b:    d1 f8                    sar    %eax</code></pre><p>　　那么，<code>OFFSET</code> 的值就是<code>0x400944</code>-<code>0x400916</code> ，也就是<code>46</code> 。</p><p>　　６、重新编译 <code>draw.c</code>.</p><pre><code class="sh">gcc -Wl,-z,norelro draw.c -o draw</code></pre><p>　　如果不出意外，这样就可以运行了。</p><p>　　运行结果是：如果有<code>M</code>个人参加，那么编号为<code>M/2</code> 的人一定会中奖。 </p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>　　接下来，揭开这个黑魔法的面纱。</p><h2 id="x86、x64的堆栈结构"><a href="#x86、x64的堆栈结构" class="headerlink" title="x86、x64的堆栈结构"></a>x86、x64的堆栈结构</h2><p>　　这个部分是在<code>black_magic()</code> 函数上体现的。</p><p>　　根据程序的流程，应该是走的第一个<code>true</code> 分支，但是，在调用了<code>black_magic()</code> 这个函数后，会神奇地走到了另一个<code>false</code> 分支。</p><p>　　这个技巧是大三时，上<code>系统级程序设计</code> 时学会的，当时老师让我们通过改变输入的4个值，对一个程序的流程进行改变，从而解密出程序的结果。这个部分关键的地方就是——改变函数的<code>返回地址</code> 。而这个就需要对堆栈结构有一定的了解。</p><p>　　首先介绍<code>x86</code> 的堆栈结构（其实这里并不严谨，这些和操作系统、编译器都很相关，有很多不同的调用约定，这里就说明一下常见的<code>cdecl</code> ）：</p><ul><li>函数栈从高地址向低地址生长</li><li>函数调用时，函数参数逆序压栈</li><li>函数返回地址在函数参数的下面</li></ul><p>　　以上是一些关键的地方，具体的可以查看<a href="https://zh.wikipedia.org/wiki/X86%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A" target="_blank" rel="noopener">X86调用约定</a> 。</p><p>　　所以，对于x86结构，函数返回地址在第一个函数参数的下面，如果需要修改返回地址，那么就需要取第一个函数参数的地址，然后减去一个字长，得到返回地址的地址，再去修改它。假设是x86平台，那么<code>black_magic()</code> 函数应该这么写：</p><pre><code class="c">void black_magic(int* incantation){  *(((int*)&amp;incantation) - 1) += *incantation;}</code></pre><p>　　其中，<code>*incantation</code> 是我们要返回的地址和原先的返回地址（函数调用的下一条指令的地址）的偏移量。并且，因为返回地址是32位的，所以将<code>&amp;incantation</code> 转换为<code>int*</code> 。</p><p>　　而对于<code>x64</code> 平台，首先可以知道，寻址的范围增大到64位；通用寄存器增加到64位，并且为了向下兼容，可以对寄存器进行8位、16位、32位的寻址，这也是为什么64位兼容32位；函数参数的传递根据参数的个数可能是通过寄存器传值，也可能是通过栈传值……大概知道这些也差不多了，如果需要更进一步的了解，可以参考以下的博客：</p><ul><li><a href="http://papap.info/2017/03/14/Linux%E4%B8%8Bx64%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%92%8C%E5%A0%86%E6%A0%88/" target="_blank" rel="noopener">Linux下x64程序的函数调用和堆栈</a></li><li><a href="https://kelvinh.github.io/blog/2013/08/05/windows-x64-calling-conventions/" target="_blank" rel="noopener">Windows平台X64函数调用约定与汇编代码分析</a></li><li><a href="https://docs.microsoft.com/zh-cn/cpp/build/overview-of-x64-calling-conventions" target="_blank" rel="noopener">Overview of x64 Calling Conventions</a></li><li><a href="http://www.cnblogs.com/HsinTsao/p/6535138.html" target="_blank" rel="noopener">X86/X64 函数调用约定</a></li><li><a href="http://www.cnblogs.com/shines77/p/3788514.html" target="_blank" rel="noopener">Windows x64汇编函数调用约定</a></li><li><a href="http://www.jianshu.com/p/5a4f2d78cb53" target="_blank" rel="noopener">x64函数调用过程分析</a></li></ul><p>　　说了这么多，那么<code>x64</code> 平台要怎么做呢？很简单，返回地址在<code>rbp</code> 寄存器的上面，而第一个参数使用<code>rdi</code> 寄存器传递。</p><p>　　分析<code>black_magic()</code> 在<code>x64</code> 平台编译后的反汇编结果：</p><pre><code>0000000000400706 &lt;black_magic&gt;:  400706:    55                       push   %rbp  400707:    48 89 e5                 mov    %rsp,%rbp  40070a:    48 89 7d f8              mov    %rdi,-0x8(%rbp)  40070e:    48 8d 45 f8              lea    -0x8(%rbp),%rax  400712:    48 83 c0 10              add    $0x10,%rax  400716:    48 8d 55 f8              lea    -0x8(%rbp),%rdx  40071a:    48 83 c2 10              add    $0x10,%rdx  40071e:    48 8b 0a                 mov    (%rdx),%rcx  400721:    48 8b 55 f8              mov    -0x8(%rbp),%rdx  400725:    8b 12                    mov    (%rdx),%edx  400727:    48 63 d2                 movslq %edx,%rdx  40072a:    48 01 ca                 add    %rcx,%rdx  40072d:    48 89 10                 mov    %rdx,(%rax)  400730:    90                       nop  400731:    5d                       pop    %rbp  400732:    c3                       retq   </code></pre><p>　　可以知道的是，在函数调用的开始，将<code>rbp</code> 寄存器压栈，将<code>rsp</code> 的值赋给<code>rbp</code> （标准的函数调用）。然后，关键的一步是，将<code>rdi</code> 寄存器的值（第一个参数）赋给<code>-0x8(%rbp)</code> ，也就是<code>rbp</code> 下面偏移一个字长。所以，综上所述，可以知道，要想获取函数的返回地址，需要获取第一个参数的地址，加上<code>1</code> 个字长得到<code>rbp</code> 的暂存地址，加上<code>2</code> 个字长得到函数返回地址。所以，假设是x64平台，那么<code>black_magic()</code> 函数应该这么写（也是我采用的）：</p><pre><code class="c">void black_magic(int* incantation){  *(((long*)&amp;incantation) + 2) += *incantation;}</code></pre><p>　　同样的，<code>*incantation</code> 是我们要返回的地址和原先的返回地址（函数调用的下一条指令的地址）的偏移量。并且，因为返回地址是64位，所以将<code>&amp;incantation</code> 转换为<code>long*</code> 。</p><h2 id="终止节与格式化字符串攻击"><a href="#终止节与格式化字符串攻击" class="headerlink" title="终止节与格式化字符串攻击"></a>终止节与格式化字符串攻击</h2><p>　　这个部分我不太想赘述，在我的另一篇博客<a href="http://w-angler.com/2016/12/05/%E7%94%A8%E4%B8%80%E4%B8%AAprintf-%E8%AF%AD%E5%8F%A5%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAweb%E6%9C%8D%E5%8A%A1%E5%99%A8/">用一个printf()语句实现一个web服务器</a>中有完整的描述。</p><h2 id="整体的流程"><a href="#整体的流程" class="headerlink" title="整体的流程"></a>整体的流程</h2><ol><li>使用Linux内核提供的真随机数发生器；</li><li>随机获取前N-1个获奖者；</li><li>假装是随机获取最后一个，但是，调用<code>black_magic()</code> 函数后，跳转到另一个分支中；</li><li>执行预先设计好的格式化字符串攻击代码，修改<code>last_dog</code> 的值，并且修改<code>终止节</code> ，使得在程序退出时，调用<code>last()</code> 函数；</li><li>非(yi)常(dian)非(ye)常(bu)意外地，第<code>M/2</code> 个人获奖了。</li></ol><h2 id="黑魔法的破灭"><a href="#黑魔法的破灭" class="headerlink" title="黑魔法的破灭"></a>黑魔法的破灭</h2><p>　　其实要破坏这个所谓的黑魔法，非常简单：</p><ul><li>换成32位系统（堆栈结构不一样）</li><li>换成windows（堆栈结构、终止节都不同）</li><li>使用低版本的gcc或者其他编译器（终止节不一样）</li></ul><h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>　　其实说实话这个并不是什么特别高深的东西，只是因为大家了解的层面不一样，所以可能会看不太懂。</p><p>　　这个实现有以下几个致命缺点：</p><ul><li>依赖于linux系统的ELF文件的格式</li><li>依赖于x86或者x64的堆栈结构</li><li>并不能做到完全的信息隐藏</li></ul><p>　　当时老师也指出了，这个代码只要多看几眼，就会发现问题的所在。</p><p>　　那节课展示的同学中，看到有利用缓冲区溢出的、修改python标准库源码的、利用自然数据的不均匀性的，以及各种代码技巧、数学方法，还是非常大开眼界的，这种开脑洞的东西确实还是非常有意思。</p><p>　　Anyway… Stay hungry. Stay foolish.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　因为之前一直很忙，没有精力写博客，这是时隔半年多来的第一篇博客。&lt;/p&gt;
&lt;p&gt;　　这篇博客的代码内容是蹭研究生的《密码学》课程时，第一节上课前老师布置的一个小任务：写一个抽奖程序并且在代码中作弊，还要尽量让别人看不出来作弊。&lt;/p&gt;
&lt;p&gt;　　虽然我的这个实现非常暴力
      
    
    </summary>
    
      <category term="奇技淫巧" scheme="https://w-angler.com/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"/>
    
    
      <category term="C" scheme="https://w-angler.com/tags/C/"/>
    
      <category term="格式化字符串攻击" scheme="https://w-angler.com/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%94%BB%E5%87%BB/"/>
    
      <category term="反汇编" scheme="https://w-angler.com/tags/%E5%8F%8D%E6%B1%87%E7%BC%96/"/>
    
      <category term="函数堆栈" scheme="https://w-angler.com/tags/%E5%87%BD%E6%95%B0%E5%A0%86%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu下git服务器搭建</title>
    <link href="https://w-angler.com/2017/02/13/ubuntu%E4%B8%8Bgit%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"/>
    <id>https://w-angler.com/2017/02/13/ubuntu下git服务器搭建/</id>
    <published>2017-02-13T15:58:07.000Z</published>
    <updated>2018-04-01T10:30:26.133Z</updated>
    
    <content type="html"><![CDATA[<p>这么早来学校了，大晚上的，折腾了一下如何搭建一个裸git服务器……</p><h1 id="git服务器的搭建"><a href="#git服务器的搭建" class="headerlink" title="git服务器的搭建"></a>git服务器的搭建</h1><p>根据我的建议，实验室新增了一台服务器，在上面搭建git服务器，从而可以满足大家的需求。</p><h2 id="一、安装ssh"><a href="#一、安装ssh" class="headerlink" title="一、安装ssh"></a>一、安装<code>ssh</code></h2><pre><code class="shell">sudo apt-get install openssh-server openssh-client</code></pre><h2 id="二、安装git"><a href="#二、安装git" class="headerlink" title="二、安装git"></a>二、安装<code>git</code></h2><pre><code class="shell">sudo apt-get install git</code></pre><h2 id="三、新增用户git"><a href="#三、新增用户git" class="headerlink" title="三、新增用户git"></a>三、新增用户<code>git</code></h2><pre><code class="shell">sudo adduser git</code></pre><p>同时，为了安全起见，将<code>用户git</code>的<code>默认shell</code>改为<code>git-shell</code></p><pre><code class="shell">sudo vim /etc/passwd</code></pre><p>将<code>用户git</code>的shell改为<code>git-shell</code></p><pre><code class="sh">git:x:1000:1000:git,,,:/home/git:/usr/bin/git-shell</code></pre><h2 id="四、切换到用户git"><a href="#四、切换到用户git" class="headerlink" title="四、切换到用户git"></a>四、切换到<code>用户git</code></h2><pre><code class="shell">sudo - git</code></pre><h2 id="五、新建目录-shh"><a href="#五、新建目录-shh" class="headerlink" title="五、新建目录.shh"></a>五、新建目录<code>.shh</code></h2><p>切换到git用户目录下，新建文件夹<code>.ssh</code></p><pre><code class="shell">mkdir .ssh</code></pre><h2 id="六、在本地生成公私钥，并将公钥添加到authorized-keys"><a href="#六、在本地生成公私钥，并将公钥添加到authorized-keys" class="headerlink" title="六、在本地生成公私钥，并将公钥添加到authorized_keys"></a>六、在本地生成公私钥，并将公钥添加到<code>authorized_keys</code></h2><p>不存在该文件的话，新建</p><pre><code class="shell">touch authorized_keys</code></pre><p>然后，将公钥添加到其中</p><pre><code class="shell">echo 公钥 &gt;&gt; authorized_keys #或者使用其他方式添加，保证一行一个密钥</code></pre><h2 id="七、创建空的git库"><a href="#七、创建空的git库" class="headerlink" title="七、创建空的git库"></a>七、创建空的git库</h2><pre><code class="shell">git init --bare 仓库名称.git</code></pre><h2 id="八、git-clone"><a href="#八、git-clone" class="headerlink" title="八、git clone"></a>八、git clone</h2><pre><code>git clone git@服务器IP:仓库名称.git</code></pre><h1 id="Gitlab才是王道啊！"><a href="#Gitlab才是王道啊！" class="headerlink" title="Gitlab才是王道啊！"></a>Gitlab才是王道啊！</h1><p>折腾了这么多之后，发现没有权限控制等功能，于是……就装了一个<a href="https://about.gitlab.com/installation/#ubuntu" target="_blank" rel="noopener">Gitlab</a>。</p><p>其实<a href="http://www.gitblit.com/" target="_blank" rel="noopener">Gitblit</a>也可以的，就是太丑了些……</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这么早来学校了，大晚上的，折腾了一下如何搭建一个裸git服务器……&lt;/p&gt;
&lt;h1 id=&quot;git服务器的搭建&quot;&gt;&lt;a href=&quot;#git服务器的搭建&quot; class=&quot;headerlink&quot; title=&quot;git服务器的搭建&quot;&gt;&lt;/a&gt;git服务器的搭建&lt;/h1&gt;&lt;p&gt;根
      
    
    </summary>
    
      <category term="git" scheme="https://w-angler.com/categories/git/"/>
    
    
      <category term="git" scheme="https://w-angler.com/tags/git/"/>
    
      <category term="ubuntu" scheme="https://w-angler.com/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>用一个printf()语句实现一个web服务器</title>
    <link href="https://w-angler.com/2016/12/05/%E7%94%A8%E4%B8%80%E4%B8%AAprintf-%E8%AF%AD%E5%8F%A5%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAweb%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://w-angler.com/2016/12/05/用一个printf-语句实现一个web服务器/</id>
    <published>2016-12-05T08:01:30.000Z</published>
    <updated>2018-04-01T10:16:18.865Z</updated>
    
    <content type="html"><![CDATA[<p>　　有这么一个笑话：<code>Jeff Dean</code>有一次用一句printf实现了一个web服务器。其他工程师添加了数千行注释但依然无法完全解释清楚其工作原理。而这个程序就是今天Google首页的前端。</p><p>　　而理论上，这个其实是可行的。</p><p>　　翻译原文：<a href="http://tinyhack.com/2014/03/12/implementing-a-web-server-in-a-single-printf-call/" target="_blank" rel="noopener">Implementing a web server in a single printf() call</a></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>　　有人刚才给我转发了一个关于<code>Jeff Dean</code>的笑话——所谓的“关于Jeff Dean的事实”（链接：<a href="https://www.zhihu.com/question/20034686/answer/20646787" target="_blank" rel="noopener">知乎</a>，<a href="https://www.quora.com/Jeff-Dean/What-are-all-the-Jeff-Dean-facts" target="_blank" rel="noopener">quora</a>），每次我看这个时，下面这条总是很突出：</p><blockquote><p>Jeff Dean有一次用一句printf实现了一个web服务器。其他工程师添加了数千行注释但依然无法完全解释清楚其工作原理。而这个程序就是今天Google首页的前端。</p></blockquote><p>　　事实上，确实可以通过一句<code>printf</code>语句来实现一个web服务器，但我发现没有人做过这个。所以这次，我决定自己实现一下。下面就是实现的代码，只有单独的一句<code>printf</code>调用，没有额外的变量或者宏定义（别担心，我会解释它是怎么工作的）：</p><p><code>web1.c</code></p><pre><code>#include &lt;stdio.h&gt;int main(int argc, char *argv[]){    printf(&quot;%*c%hn%*c%hn&quot;     &quot;\xeb\x3d\x48\x54\x54\x50\x2f\x31\x2e\x30\x20\x32&quot;     &quot;\x30\x30\x0d\x0a\x43\x6f\x6e\x74\x65\x6e\x74\x2d&quot;     &quot;\x74\x79\x70\x65\x3a\x74\x65\x78\x74\x2f\x68\x74&quot;     &quot;\x6d\x6c\x0d\x0a\x0d\x0a\x3c\x68\x31\x3e\x48\x65&quot;     &quot;\x6c\x6c\x6f\x20\x57\x6f\x72\x6c\x64\x21\x3c\x2f&quot;     &quot;\x68\x31\x3e\x4c\x8d\x2d\xbc\xff\xff\xff\x48\x89&quot;     &quot;\xe3\x48\x83\xeb\x10\x48\x31\xc0\x50\x66\xb8\x1f&quot;     &quot;\x90\xc1\xe0\x10\xb0\x02\x50\x31\xd2\x31\xf6\xff&quot;     &quot;\xc6\x89\xf7\xff\xc7\x31\xc0\xb0\x29\x0f\x05\x49&quot;     &quot;\x89\xc2\x31\xd2\xb2\x10\x48\x89\xde\x89\xc7\x31&quot;     &quot;\xc0\xb0\x31\x0f\x05\x31\xc0\xb0\x05\x89\xc6\x4c&quot;     &quot;\x89\xd0\x89\xc7\x31\xc0\xb0\x32\x0f\x05\x31\xd2&quot;     &quot;\x31\xf6\x4c\x89\xd0\x89\xc7\x31\xc0\xb0\x2b\x0f&quot;     &quot;\x05\x49\x89\xc4\x48\x31\xd2\xb2\x3d\x4c\x89\xee&quot;     &quot;\x4c\x89\xe7\x31\xc0\xff\xc0\x0f\x05\x31\xf6\xff&quot;     &quot;\xc6\xff\xc6\x4c\x89\xe7\x31\xc0\xb0\x30\x0f\x05&quot;     &quot;\x4c\x89\xe7\x31\xc0\xb0\x03\x0f\x05\xeb\xc3&quot;,    ((((unsigned long int)0x4005c8+12)&gt;&gt;16)&amp;0xffff),    0,0x00000000006007D8+2,    (((unsigned long int)0x4005c8+12)&amp;0xffff)-((((unsigned long int)0x4005c8+12)&gt;&gt;16)&amp;0xffff),    0, 0x00000000006007D8 );}</code></pre><p>　　这段代码只能在64位的linux系统上运行（可能还和gcc的版本有关）。下面编译它：</p><pre><code>gcc -g web1.c -o webserver</code></pre><p>　　你们可能已经猜到了，我使用了一段特殊的格式化字符串欺骗了你们。这段代码可能并不能在你的机器上运行，因为我硬编码了两个内存地址。</p><p>　　下面这个版本可能更明了一些（也容易修改一些），但是你依然需要改变两个值（后面我会解释）：<code>FUNCTION_ADDR</code>和<code>DESTADDR</code>。</p><pre><code>#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;stdint.h&gt;#define FUNCTION_ADDR ((uint64_t)0x4005c8 + 12)#define DESTADDR 0x00000000006007D8#define a (FUNCTION_ADDR &amp; 0xffff)#define b ((FUNCTION_ADDR &gt;&gt; 16) &amp; 0xffff)int main(int argc, char *argv[]){    printf(&quot;%*c%hn%*c%hn&quot;     &quot;\xeb\x3d\x48\x54\x54\x50\x2f\x31\x2e\x30\x20\x32&quot;     &quot;\x30\x30\x0d\x0a\x43\x6f\x6e\x74\x65\x6e\x74\x2d&quot;     &quot;\x74\x79\x70\x65\x3a\x74\x65\x78\x74\x2f\x68\x74&quot;     &quot;\x6d\x6c\x0d\x0a\x0d\x0a\x3c\x68\x31\x3e\x48\x65&quot;     &quot;\x6c\x6c\x6f\x20\x57\x6f\x72\x6c\x64\x21\x3c\x2f&quot;     &quot;\x68\x31\x3e\x4c\x8d\x2d\xbc\xff\xff\xff\x48\x89&quot;     &quot;\xe3\x48\x83\xeb\x10\x48\x31\xc0\x50\x66\xb8\x1f&quot;     &quot;\x90\xc1\xe0\x10\xb0\x02\x50\x31\xd2\x31\xf6\xff&quot;     &quot;\xc6\x89\xf7\xff\xc7\x31\xc0\xb0\x29\x0f\x05\x49&quot;     &quot;\x89\xc2\x31\xd2\xb2\x10\x48\x89\xde\x89\xc7\x31&quot;     &quot;\xc0\xb0\x31\x0f\x05\x31\xc0\xb0\x05\x89\xc6\x4c&quot;     &quot;\x89\xd0\x89\xc7\x31\xc0\xb0\x32\x0f\x05\x31\xd2&quot;     &quot;\x31\xf6\x4c\x89\xd0\x89\xc7\x31\xc0\xb0\x2b\x0f&quot;     &quot;\x05\x49\x89\xc4\x48\x31\xd2\xb2\x3d\x4c\x89\xee&quot;     &quot;\x4c\x89\xe7\x31\xc0\xff\xc0\x0f\x05\x31\xf6\xff&quot;     &quot;\xc6\xff\xc6\x4c\x89\xe7\x31\xc0\xb0\x30\x0f\x05&quot;     &quot;\x4c\x89\xe7\x31\xc0\xb0\x03\x0f\x05\xeb\xc3&quot;,    b, 0, DESTADDR + 2, a-b, 0, DESTADDR );}</code></pre><p>　　我会通过下面这些简短的C代码解释上面的是怎样工作的。</p><p>　　第一个，我们如何不通过显式的函数调用来运行另一段代码？下面是一个例子：</p><p><code>run-finalizer.c</code></p><pre><code>#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;#define ADDR 0x00000000600720void hello(){    printf(&quot;hello world\n&quot;);}int main(int argc, char *argv[]){    (*((unsigned long int*)ADDR))=(unsigned long int)hello;}</code></pre><p>　　你可以编译它，但是它可能并不能在你的系统上运行（会出现段错误），你需要按照以下的步骤来：</p><hr><p><strong>注：</strong></p><p>Ubuntu添加了一个在最终的<a href="http://baike.baidu.com/subview/1090277/10973487.htm#viewPageContent" target="_blank" rel="noopener">ELF</a>中提供只读的重定位表的安全机制。为了能够在ubuntu上运行这些例子，在编译时需要添加以下这些参数：</p><blockquote><p><code>-Wl,-z,norelro</code></p></blockquote><p>例如：</p><blockquote><p><code>gcc -Wl,-z,norelro test.c</code></p></blockquote><hr><p>　　1、编译这段代码：</p><pre><code>gcc run-finalizer.c -o run-finalizer</code></pre><p>　　2、查看<code>.fini_array</code>（译者注：相关资料，<a href="http://docs.oracle.com/cd/E19253-01/819-7050/chapter3-1/" target="_blank" rel="noopener">链接程序和库指南</a>，<a href="http://docs.oracle.com/cd/E19253-01/819-7050/6n918j8mn/index.html#chapter2-48195" target="_blank" rel="noopener">初始化和终止节</a>，<a href="http://stackoverflow.com/questions/26292964/when-will-the-fini-array-section-being-used" target="_blank" rel="noopener">When will the .fini_array section being used?</a>）的地址：</p><pre><code>objdump -h -j .fini_array run-finalizer</code></pre><p>　　然后找到<code>VMA</code>（Virtual Memory Area，虚拟内存空间）的地址：</p><pre><code>run-finalizer：     文件格式 elf64-x86-64节：Idx Name          Size      VMA               LMA               File off  Algn19 .fini_array   00000008  00000000006007d8  00000000006007d8  000007d8  2**3                 CONTENTS, ALLOC, LOAD, DATA</code></pre><p>　　你最好使用最新版本的GCC来编译，老版本使用不同的机制来存储<code>终止例程</code>（资料：<a href="http://docs.oracle.com/cd/E19253-01/819-7050/6n918j8n2/index.html" target="_blank" rel="noopener">初始化和终止例程</a>）。</p><p>　　3、将<code>ADDR</code>改为<code>VMA</code>的值；</p><p>　　4、再次编译；</p><p>　　5、运行。</p><p>　　然后你应该可以看到在屏幕上打印出了”hello world”。</p><p>　　那它到底是怎么实现的呢？</p><p>　　根据<a href="http://refspecs.linuxbase.org/LSB_3.1.1/LSB-Core-generic/LSB-Core-generic/specialsections.html" target="_blank" rel="noopener">Chapter 11 of Linux Standard Base Core Specification 3.1</a>：</p><blockquote><p>.fini_array 这个节包含了一个函数指针数组，在含有这个部分的可执行文件或者共享对象中作为一个单独的终止函数数组（termination array）。</p></blockquote><blockquote><p>This section holds an array of function pointers that contributes to a single termination array for the executable or shared object containing the section.</p></blockquote><p>　　我们强制覆盖这个数组，这样<code>hello</code>函数就可以被调用了。如果你要编译上面的web服务器的代码，<code>ADDR</code>的值需要用同样方法来修改（使用<code>objdump</code>）。</p><p>　　现在我们知道如何通过覆盖某一个特定的地址来执行一个函数，接下来我们需要知道的是，如何使用<code>printf</code>来覆盖这个地址。你可以找到很多关于<code>格式化字符串攻击</code>的教程，在这里我试着做一个简短的解释。</p><hr><p>注：<code>格式化字符串攻击</code>（漏洞），是一种很古老的漏洞。可以查看下面的博客了解一下：</p><ul><li><a href="http://www.tuicool.com/articles/IniyYzA" target="_blank" rel="noopener">漏洞挖掘基础之格式化字符串</a></li><li><a href="http://www.freebuf.com/articles/system/74224.html" target="_blank" rel="noopener">格式化字符串的漏洞利用</a></li><li><a href="http://blog.csdn.net/immcss/article/details/6267849" target="_blank" rel="noopener">格式化字符串攻击原理及示例 </a></li></ul><hr><p>　　<code>printf</code>函数可以通过<code>%n</code>这个格式化字符来获取我们已经输出了多少个字符，例如：</p><pre><code>#include &lt;stdio.h&gt;int main(){    int count;    printf(&quot;AB%n&quot;, &amp;count);    printf(&quot;\n%d characters printed\n&quot;, count);}</code></pre><p>　　结果为：</p><pre><code>AB2 characters printed</code></pre><p>　　我们可以将任何内存地址放在<code>count</code>上来覆盖该地址的值。但是如果需要覆盖一个很大的地址值的话，我们需要打印大量的字符，这个是很傻的。幸运的是，另外一个格式化字符<code>%hn</code>作用于<code>short</code>而不是<code>int</code>，我们可以一次覆盖2个字节，从而组成一个我们想要的4字节的值。</p><p>　　接下来让我们试一下，使用两次<code>printf</code>调用，用我们想要的值（这里是函数<code>hello</code>的指针值）来覆盖<code>.fini_array</code>：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#define FUNCTION_ADDR ((uint64_t)hello)#define DESTADDR 0x0000000000600948void hello(){    printf(&quot;\n\n\n\nhello world\n\n&quot;);}int main(int argc, char *argv[]){    short a= FUNCTION_ADDR &amp; 0xffff;    short b = (FUNCTION_ADDR &gt;&gt; 16) &amp; 0xffff;    printf(&quot;a = %04x b = %04x\n&quot;, a, b);fflush(stdout);    uint64_t *p = (uint64_t*)DESTADDR;    printf(&quot;before: %08lx\n&quot;, *p); fflush(stdout);    printf(&quot;%*c%hn&quot;, b, 0, DESTADDR + 2 );fflush(stdout);    printf(&quot;after1: %08lx\n&quot;, *p); fflush(stdout);    printf(&quot;%*c%hn&quot;, a, 0, DESTADDR);fflush(stdout);    printf(&quot;after2: %08lx\n&quot;, *p); fflush(stdout);    return 0;}</code></pre><p>　　其中关键的部分是：</p><pre><code>short a= FUNCTION_ADDR &amp; 0xffff;short b = (FUNCTION_ADDR &gt;&gt; 16) &amp; 0xffff;printf(&quot;%*c%hn&quot;, b, 0, DESTADDR + 2 );printf(&quot;%*c%hn&quot;, a, 0, DESTADDR);</code></pre><p>　　<code>a</code>和<code>b</code>其实就是函数地址值的一半（译者注：指针占4个字节，a、b是前后的两个字节），我们可以构建一个长度为<code>a</code>和<code>b</code>的字符串给<code>printf</code>函数输出，但这样就太繁琐了，所以我选择使用<code>%*</code>这个格式化字符，它可以通过参数来控制输出的长度。</p><p>　　例如，下面的代码：</p><pre><code>printf(&quot;%*c&quot;, 10, &#39;A&#39;);</code></pre><p>　　它将会打印9个空格，紧随着输出字符<code>A</code>。所以，总共输出10个字符。</p><p>　　如果我们想只用一次<code>printf</code>，我们就需要记得，已经打印了<code>b</code>个字节，所以我们还需要打印另外的<code>b-a</code>（可能为负）个字节（输出的计数器是累加的）。</p><pre><code>printf(&quot;%*c%hn%*c%hn&quot;, b, 0, DESTADDR + 2, b-a, 0, DESTADDR );</code></pre><p>　　例子中我们使用的是<code>hello</code>函数，但是实际上我们可以调用任何函数（或者说，任何地址）。我已经编写了一个只输出<code>Hello world</code>的web服务器的<code>shellcode</code>，如下：</p><pre><code>unsigned char hello[] =     &quot;\xeb\x3d\x48\x54\x54\x50\x2f\x31\x2e\x30\x20\x32&quot;    &quot;\x30\x30\x0d\x0a\x43\x6f\x6e\x74\x65\x6e\x74\x2d&quot;    &quot;\x74\x79\x70\x65\x3a\x74\x65\x78\x74\x2f\x68\x74&quot;    &quot;\x6d\x6c\x0d\x0a\x0d\x0a\x3c\x68\x31\x3e\x48\x65&quot;    &quot;\x6c\x6c\x6f\x20\x57\x6f\x72\x6c\x64\x21\x3c\x2f&quot;    &quot;\x68\x31\x3e\x4c\x8d\x2d\xbc\xff\xff\xff\x48\x89&quot;    &quot;\xe3\x48\x83\xeb\x10\x48\x31\xc0\x50\x66\xb8\x1f&quot;    &quot;\x90\xc1\xe0\x10\xb0\x02\x50\x31\xd2\x31\xf6\xff&quot;    &quot;\xc6\x89\xf7\xff\xc7\x31\xc0\xb0\x29\x0f\x05\x49&quot;    &quot;\x89\xc2\x31\xd2\xb2\x10\x48\x89\xde\x89\xc7\x31&quot;    &quot;\xc0\xb0\x31\x0f\x05\x31\xc0\xb0\x05\x89\xc6\x4c&quot;    &quot;\x89\xd0\x89\xc7\x31\xc0\xb0\x32\x0f\x05\x31\xd2&quot;    &quot;\x31\xf6\x4c\x89\xd0\x89\xc7\x31\xc0\xb0\x2b\x0f&quot;    &quot;\x05\x49\x89\xc4\x48\x31\xd2\xb2\x3d\x4c\x89\xee&quot;    &quot;\x4c\x89\xe7\x31\xc0\xff\xc0\x0f\x05\x31\xf6\xff&quot;    &quot;\xc6\xff\xc6\x4c\x89\xe7\x31\xc0\xb0\x30\x0f\x05&quot;    &quot;\x4c\x89\xe7\x31\xc0\xb0\x03\x0f\x05\xeb\xc3&quot;;</code></pre><hr><p>注：<code>shellcode</code>是一种利用溢出漏洞来执行的特定代码。相关资料如下：</p><ul><li><a href="http://blog.csdn.net/maotoula/article/details/18502679" target="_blank" rel="noopener">Shellcode的原理及编写 </a></li><li><a href="http://blog.chinaunix.net/uid-24917554-id-3506660.html" target="_blank" rel="noopener">Shellcode的编写</a></li><li><a href="http://blog.chinaunix.net/uid-571104-id-2734570.html" target="_blank" rel="noopener">ShellCode的简单原理</a></li><li><a href="http://netsecurity.51cto.com/art/201211/367420.htm" target="_blank" rel="noopener">堆栈溢出技术从入门到高深：如何书写shell code</a></li><li><a href="http://zhaisj.blog.51cto.com/219066/61428/" target="_blank" rel="noopener">了解黑客的关键工具—揭开Shellcode的神秘面纱</a></li></ul><hr><p>　　如果我们将<code>hello</code>函数移除，插入上面的<code>shellcode</code>的话，这段<code>shellcode</code>就会被执行。</p><p>　　这个<code>shellcode</code>其实就是一个字符串（或者说，可以看做），所以我们可以将它插入到<code>%*c%hn%*c%hn</code>的后面。这个字符串是未命名的，所以我们需要在编译后找到它的地址。为了获取这个地址，我们需要编译这个代码，然后反编译为汇编：</p><p><code>objdump -d webserver</code></p><pre><code>............00000000004004e6 &lt;main&gt;:  4004e6:    55                       push   %rbp  4004e7:    48 89 e5                 mov    %rsp,%rbp  4004ea:    48 83 ec 10              sub    $0x10,%rsp  4004ee:    89 7d fc                 mov    %edi,-0x4(%rbp)  4004f1:    48 89 75 f0              mov    %rsi,-0x10(%rbp)  4004f5:    48 83 ec 08              sub    $0x8,%rsp  4004f9:    68 d8 07 60 00           pushq  $0x6007d8  4004fe:    41 b9 00 00 00 00        mov    $0x0,%r9d  400504:    41 b8 94 05 00 00        mov    $0x594,%r8d  40050a:    b9 da 07 60 00           mov    $0x6007da,%ecx  40050f:    ba 00 00 00 00           mov    $0x0,%edx  400514:    be 40 00 00 00           mov    $0x40,%esi  400519:    bf c8 05 40 00           mov    $0x4005c8,%edi  40051e:    b8 00 00 00 00           mov    $0x0,%eax  400523:    e8 98 fe ff ff           callq  4003c0 &lt;printf@plt&gt;  400528:    48 83 c4 10              add    $0x10,%rsp  40052c:    b8 00 00 00 00           mov    $0x0,%eax  400531:    c9                       leaveq   400532:    c3                       retq     400533:    66 2e 0f 1f 84 00 00     nopw   %cs:0x0(%rax,%rax,1)  40053a:    00 00 00   40053d:    0f 1f 00                 nopl   (%rax)............</code></pre><p>　　我们需要关心的是这一行：</p><pre><code>mov    $0x4005c8,%edi</code></pre><p>　　这个<code>0x4005c8</code>就是我们在这里需要的地址：</p><pre><code>#define FUNCTION_ADDR ((uint64_t)0x4005c8 + 12)</code></pre><p>　　这里的<code>+12</code>是必需的，因为我们的<code>shellcode</code>紧跟在字符串<code>%*c%hn%*c%hn</code>后，而它的长度是12个字符。</p><p>　　如果你对<code>shellcode</code>的来源感兴趣的话，它其实来自以下的C代码：</p><pre><code>#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;sys/socket.h&gt;#include&lt;arpa/inet.h&gt;#include&lt;netdb.h&gt;#include&lt;signal.h&gt;#include&lt;fcntl.h&gt;int main(int argc, char *argv[]){    int sockfd = socket(AF_INET, SOCK_STREAM, 0);    struct sockaddr_in serv_addr;    bzero((char *)&amp;serv_addr, sizeof(serv_addr));    serv_addr.sin_family = AF_INET;    serv_addr.sin_addr.s_addr = INADDR_ANY;    serv_addr.sin_port = htons(8080);    bind(sockfd, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr));    listen(sockfd, 5);    while (1) {        int cfd  = accept(sockfd, 0, 0);        char *s = &quot;HTTP/1.0 200\r\nContent-type:text/html\r\n\r\n&lt;h1&gt;Hello world!&lt;/h1&gt;&quot;;         if (fork()==0) {            write(cfd, s, strlen(s));            shutdown(cfd, SHUT_RDWR);            close(cfd);        }        }    return 0;}</code></pre><p>　　另外，我还做了一些额外的工作，从<code>shellcode</code>中移除了所有的<code>NUL</code>字符（尽管这个并不是必需的）。</p><blockquote><p><code>Jeff Dean</code>有一次用一句printf实现了一个web服务器。其他工程师添加了数千行注释但依然无法完全解释清楚其工作原理。而这个程序就是今天Google首页的前端。</p></blockquote><p>　　作为练习，读者可以自己修改一下这个web服务器，让它可以支持<code>Google搜索</code>前端的加载。</p><p>　　这篇博客的代码可以在这里找到：<a href="https://github.com/yohanes/printf-webserver" target="_blank" rel="noopener">https://github.com/yohanes/printf-webserver</a></p><p>　　对于那些认为这个毫无用处的人，我只想说：没错！它就是毫无用处！我只是恰好喜欢这个挑战，并且在解决这个问题的过程中，我刷新了对这些知识的认识：<code>shellcode</code>的编写（我已经几年没写过了）、<code>AMD64</code>平台的汇编、系统调用、<code>objdump</code>、<code>.fini_array</code>（上次我检查时，发现gcc还在用<code>.dtors</code>）、<code>printf</code>的格式化字符漏洞、<code>gdb</code>的使用技巧（例如将内存块导出为文件）以及低层次的<code>socket</code>编程（之前我一直使用<code>boost</code>）。</p><h1 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h1><p>　　最初看到这个笑话时，没有想到真的可以实现，原文作者真的是一个很geek的大神，在翻译的过程中，我学到了很多东西，例如动态链接、内存布局、函数调用栈、格式化字符串攻击等等。翻译的比较随便，很多术语没接触过，也翻译不出来，如果看得不是舒爽，可以直接看原文。</p><p>　　我的运行结果：</p><p><img src="run.png" alt=""></p><p><img src="result.png" alt=""></p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>　　很多人说没有看明白，我就根据自己的理解解释一下吧。</p><p>　　首先，这里涉及的技术有<code>动态链接库</code>的加载、初始化、卸载、终止等（上面有相关的资料），<code>格式化字符串攻击</code>，<code>shellcode</code>的原理及编写……</p><p>　　关键的一点是，覆盖<code>.fini_array</code>这个节，这个节的代码将会在动态链接库（或者可执行程序）卸载时被执行。这里再次给出相关的资料链接，<a href="http://docs.oracle.com/cd/E19253-01/819-7050/6n918j8mn/index.html#chapter2-48195" target="_blank" rel="noopener">初始化和终止节</a>。从中我们也可以知道，为什么是要覆盖终止节而不是初始化节，因为我们需要先使用printf()修改.fini_array节的内容，然后在程序结束时，这个节的内容就会被执行，覆盖初始化节的话，没有什么用，因为程序已经执行过修改前的初始化代码了。这个<code>初始化</code>和<code>终止节</code>，可以理解为C++中的<code>构造函数</code>和<code>析构函数</code>，只不过，涉及的不是类，而是链接库或者可执行程序。</p><p>　　其次，格式化字符串攻击。这个看一下上面的资料就能明白了，主要原理就是通过格式化字符串修改某个内存地址的值。这里就是通过这个来修改.fini_array。</p><p>　　最后，<code>shellcode</code>部分，这个就很geek了，具体原理以及shellcode的编写上面有相关的资料。原文作者已经编写了一个简单的web服务器的shellcode，.fini_array的值被修改为它的地址，所以它会在程序结束时被执行。理论上，只要你的shellcode有这么复杂，你几乎可以使用一句printf实现任何功能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　有这么一个笑话：&lt;code&gt;Jeff Dean&lt;/code&gt;有一次用一句printf实现了一个web服务器。其他工程师添加了数千行注释但依然无法完全解释清楚其工作原理。而这个程序就是今天Google首页的前端。&lt;/p&gt;
&lt;p&gt;　　而理论上，这个其实是可行的。&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="奇技淫巧" scheme="https://w-angler.com/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"/>
    
    
      <category term="C" scheme="https://w-angler.com/tags/C/"/>
    
      <category term="格式化字符串攻击" scheme="https://w-angler.com/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%94%BB%E5%87%BB/"/>
    
      <category term="终止节" scheme="https://w-angler.com/tags/%E7%BB%88%E6%AD%A2%E8%8A%82/"/>
    
      <category term="ELF" scheme="https://w-angler.com/tags/ELF/"/>
    
      <category term="ShellCode" scheme="https://w-angler.com/tags/ShellCode/"/>
    
  </entry>
  
  <entry>
    <title>Y组合子及其实现</title>
    <link href="https://w-angler.com/2016/11/18/Y%E7%BB%84%E5%90%88%E5%AD%90%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/"/>
    <id>https://w-angler.com/2016/11/18/Y组合子及其实现/</id>
    <published>2016-11-18T15:24:07.000Z</published>
    <updated>2018-04-01T16:19:08.408Z</updated>
    
    <content type="html"><![CDATA[<p>　　递归大家都知道，就是在一个函数体里面调用函数本身。而在无类型lambda演算中，因为函数的匿名性，为了表示递归，需要用到一个很trick的东西——Y组合子。</p><h1 id="lambda演算"><a href="#lambda演算" class="headerlink" title="lambda演算"></a>lambda演算</h1><p>　　在我的另一篇博客<a href="http://w-angler.com/2016/10/08/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8F%8AJVM%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/">lambda表达式及JVM语言实现的一些思考</a>中，提到过lamdba演算和lambda表达式，以及它们之间的关系。这里就不再赘述了。</p><p>　　参考资料：</p><ul><li>维基百科：<a href="https://zh.wikipedia.org/wiki/%CE%9B%E6%BC%94%E7%AE%97" target="_blank" rel="noopener">λ演算</a></li><li><a href="http://mindhacks.cn/2006/10/15/cantor-godel-turing-an-eternal-golden-diagonal/" target="_blank" rel="noopener">康托尔、哥德尔、图灵——永恒的金色对角线</a></li><li><a href="http://cgnail.github.io/tags/#lambda%E6%BC%94%E7%AE%97" target="_blank" rel="noopener">lambda演算</a></li></ul><h1 id="Y组合子"><a href="#Y组合子" class="headerlink" title="Y组合子"></a>Y组合子</h1><p>　　在讲Y组合子之前，先解释一下<code>不动点</code>的概念。</p><p>　　在数学中，我们知道，如果一个函数<code>f(x)</code>的结果与自变量x相等，即<code>f(x)=x</code>，那么则称它为函数的不动点。</p><p>　　类似地，如果某个高阶函数接受一个函数作为参数，返回值也为这个函数，那么我们可以称这个函数为高阶函数的不动点。例如，<code>F(x)</code>接受一个函数<code>h(x)</code>，返回了<code>h(x)</code>，即<code>F(h(x))=h(x)</code>，那么<code>h(x)</code>这个函数就是高阶函数<code>F(x)</code>的<code>不动点</code>。</p><p>　　这个有什么用？</p><p>　　首先要知道的是，在lambda演算中，并没有<code>函数名</code>这个概念，也是说，不能像下面这样定义一个函数（Haskell定义）：</p><pre><code>f x=if x&gt;1 then x*(f x-1) else 1</code></pre><p>　　像Haskell、Lisp这种函数式语言中，函数都是可以有一个对应的名称的，但是在lambda演算中，却不能这样，因为函数都是匿名的，无法在函数体内调用自己本身。</p><p>　　于是，不动点派上用场了。假设我们需要构建一个叫<code>F</code>（只是一个代词，它仍然是匿名函数）的匿名递归函数，同时，<code>f</code>是<code>F</code>的不动点的话，那么，如果我们可以算出这个f，即<code>F(f)=f</code>，也就是<code>f=F(f)=F(F(f))=...</code>的话，那么，很明显，我们就可以表示匿名的递归了。</p><p>　　而<code>Y组合子</code>的作用，就是计算出函数的不动点组合子，从而实现函数的递归。Y组合子是由<a href="https://zh.wikipedia.org/wiki/%E5%93%88%E6%96%AF%E5%87%B1%E7%88%BE%C2%B7%E5%8A%A0%E9%87%8C" target="_blank" rel="noopener">Haskell B. Curry</a>发现的。</p><p>　　Y组合子的描述如下：</p><pre><code>λf.(λx.(f (x x)) λx.(f (x x)))</code></pre><p>　　看到这里你可能一头雾水，没事，我们演算一遍试试。</p><p>　　为了看起来容易理解一些，下面我们用Y代替上面的Y组合子。即：</p><pre><code>Y=λf.(λx.(f (x x)) λx.(f (x x))) </code></pre><p>　　以一个函数h为例，我们可以看下如何通过Y组合子求出一个不动点组合子的：</p><pre><code> (Y h)=(λf.(λx.(f (x x)) λx.(f (x x))) h)=(λx.(h (x x)) λx.(h (x x)))=(λy.(h (y y)) λx.(h (x x)))=(h (λx.(h (x x)) λx.(h (x x))))=(h (Y h))</code></pre><p>　　可以看出，(Y h)就是h的不动点组合子。</p><h1 id="Y组合子的实现"><a href="#Y组合子的实现" class="headerlink" title="Y组合子的实现"></a>Y组合子的实现</h1><p>　　由上面可知，Y组合子在lambda演算是非常重要的，它进一步证明了lambda演算与图灵机的等价（就是说，它和图灵机可以表示递归，在类型系统的表示上是等价的）。</p><p>　　但是在实际的编程中，即使是函数式语言，也不需要用Y组合子（因为我们的计算机是建立在图灵机之上的，函数式语言的实现依靠于图灵机而不是lambda演算。这个进一步可以看出lambda演算和图灵机的等价），他们都提供了非匿名的递归函数支持。</p><p>　　但是我们可以通过编程实现Y组合子来加深对它的理解。</p><p>　　以下是它的一些实现：</p><p><code>Python</code>:</p><pre><code>def Y(f):    return (lambda h: h(h))(lambda x: f(lambda *args: x(x)(*args)))</code></pre><p><code>JavaScript</code>:</p><pre><code>var Y = function(f) {    return (function(h) {        return h(h);    })(function(x) {        return f(function() {            return x(x).apply(null, arguments);        });    });};</code></pre><p><code>Common-Lisp</code>:</p><pre><code>(defun Y (f)    ((lambda (h)        (funcall h h))        (lambda (x)        (funcall f (lambda (&amp;rest args)              (apply (funcall x x) args))))))</code></pre><p><code>Groovy</code>:</p><pre><code>def Y = {    h -&gt; ({        f -&gt; f(f)    })({        f -&gt; h{            x -&gt; f(f)(x)        }    })}</code></pre><p>　　好吧，尝试使用java 的lambda表达式来写，发现写不了。</p><hr><p>　　我都佩服我自己，行数控制在10行左右用Java实现了！</p><p><code>Java</code>:</p><pre><code>public class YCombinator {    @FunctionalInterface    interface Combinator&lt;E&gt; {        public E call(Object... args);    }    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })    public static Combinator&lt;Combinator&gt; Y(final Combinator&lt;Combinator&gt; f) {        return (Combinator&lt;Combinator&gt;) ((Combinator)(args1-&gt;{            final Combinator&lt;Combinator&gt; h = (Combinator&lt;Combinator&gt;)args1[0];            return h.call(h);        })).call((Combinator)(args2-&gt;{            final Combinator&lt;Combinator&gt; x=(Combinator&lt;Combinator&gt;)args2[0];            return f.call((Combinator)(args3-&gt;{                return x.call(x).call(args3);            }));        }));    }    @SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })    public static void main(String[] s) {        //A simple test        Combinator&lt;Combinator&gt; y = Y((Combinator&lt;Combinator&gt;)(args-&gt;{            final Combinator&lt;Integer&gt; f = (Combinator&lt;Integer&gt;)args[0];            return x-&gt;{                int n = Integer.parseInt(x[0].toString());                return n==1?n:n*f.call(n-1);            };        }));        System.out.println(y.call(233));    }}interface Combinator&lt;F&gt; extends Function&lt;Combinator&lt;F&gt;, F&gt; {}public static &lt;A,B&gt; Function&lt;A,B&gt; Y(Function&lt;Function&lt;A,B&gt;, Function&lt;A,B&gt;&gt; f){    Combinator&lt;Function&lt;A,B&gt;&gt; r = w -&gt; f.apply(x -&gt; w.apply(w).apply(x));    return r.apply(r);}</code></pre><p>　　不得不说，Java的lambda实在太坑，居然还需要类型转换……</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　递归大家都知道，就是在一个函数体里面调用函数本身。而在无类型lambda演算中，因为函数的匿名性，为了表示递归，需要用到一个很trick的东西——Y组合子。&lt;/p&gt;
&lt;h1 id=&quot;lambda演算&quot;&gt;&lt;a href=&quot;#lambda演算&quot; class=&quot;headerl
      
    
    </summary>
    
      <category term="PLT" scheme="https://w-angler.com/categories/PLT/"/>
    
    
      <category term="Y组合子" scheme="https://w-angler.com/tags/Y%E7%BB%84%E5%90%88%E5%AD%90/"/>
    
      <category term="PLT" scheme="https://w-angler.com/tags/PLT/"/>
    
      <category term="Lambda" scheme="https://w-angler.com/tags/Lambda/"/>
    
  </entry>
  
  <entry>
    <title>位掩码</title>
    <link href="https://w-angler.com/2016/10/30/%E4%BD%8D%E6%8E%A9%E7%A0%81/"/>
    <id>https://w-angler.com/2016/10/30/位掩码/</id>
    <published>2016-10-29T23:52:15.000Z</published>
    <updated>2018-04-01T10:19:19.740Z</updated>
    
    <content type="html"><![CDATA[<p>　　位运算符有很多，例如与(&amp;)、或(|)、非(~)、异或(^)、移位(&lt;&lt;和&gt;&gt;)等。几乎每种语言都提供了对位运算的支持，但是，这些运算符在日常的编程中很少会用到（Ｃ语言中倒是经常可以看到，特别是在嵌入式开发中，最近看的一个智能卡系统中，几乎都是位运算）。位运算相对于普通的操作来说，速度会快一些。这里讲一下一个很常见的位运算的应用——位掩码（BitMask）。</p><h1 id="位掩码及其应用"><a href="#位掩码及其应用" class="headerlink" title="位掩码及其应用"></a>位掩码及其应用</h1><p>　　在Web开发中，为了实现一个良好的访问控制系统，权限和角色管理是个很重要的部分，而如何保存、修改某个角色的权限，是个很值得思考的问题（当然，这个在任何涉及权限控制的系统中都适用）。而在某些情况下，某个组件可能具有多个可叠加的属性状态，这个也可以使用位掩码。</p><p>　　在这种情况下，使用位掩码的话，可以提供很大的灵活性，并且可以相对地减少存储空间（相对于你使用权限的集合或者多个布尔值来表示）。</p><p>　　位掩码的思想是，每个位表示一种权限或者属性，<code>1</code>表示具有，<code>0</code>表示不具有。这样，仅仅使用<code>n</code>个位，就可以表示<code>2^n</code>个权限状态。</p><p>　　举个栗子，数据库的基本操作：增（INSERT）、删（DELETE）、改（UPDATE）、查（SELECT）。我们需要四个位来表示这些权限：</p><pre><code>int INSERT=1&lt;&lt;0;//0001int DELETE=1&lt;&lt;1;//0010int UPDATE=1&lt;&lt;2;//0100int SELECT=1&lt;&lt;3;//1000</code></pre><p>　　如果我们以变量<code>permission</code>存储权限的话，以<code>INSERT</code>为例，可以有下面这些操作：</p><pre><code>permission|=INSERT;//添加权限permission&amp;=~INSERT;//删除权限bool allowed=(permission&amp;INSERT)==INSERT;//是否具有权限</code></pre><p>　　这样看起来是不是很简单明了？</p><p>　　位掩码一个很经典的使用例子就是，Linux系统下文件权限的表示。当初看到它使用1、2、4来表示读、写、执行权限时，觉得很精妙，也很奇怪为什么是这些魔数？现在明白了，因为这都是每个单独的权限位的值。还有就是类Unix系统下的文件操作权限（还记得被文件读写的各种权限位支配的恐惧吗？）：</p><pre><code>int fd = open(SOURCE, O_RDWR | O_APPEND);//具备读写和尾追加权限的文件描述符</code></pre><p>　　熟悉安卓开发的童鞋，可能会对位掩码有很熟悉的感觉，因为在安卓开发中，位掩码的使用是非常频繁的（据说是使用枚举比较占内存，所以不用枚举，滑稽）。在设置组件的布局时，常常可以见到这样类似的代码：</p><pre><code>android:gravity=&quot;bottom|right&quot;</code></pre><h1 id="位运算的其他应用"><a href="#位运算的其他应用" class="headerlink" title="位运算的其他应用"></a>位运算的其他应用</h1><p>　　位运算其实是非常有用的。暑假时我在<code>codewars</code>刷题，遇到这样一题（链接：<a href="https://www.codewars.com/kata/54da5a58ea159efa38000836" target="_blank" rel="noopener">Find the odd int</a>），大概意思是：给你一个整型数组，找出其中出现了奇数次的数（只存在一个）。</p><p>　　这个是我最初的解法，我都看不下去了：</p><pre><code>import java.util.Arrays;import java.util.function.Function;import java.util.stream.Collectors;public class FindOdd {    public static int findIt(int[] A) {        return Arrays.stream(A)            .boxed()            .collect(Collectors.groupingBy(Function.identity(),Collectors.counting()))            .entrySet()            .stream()            .filter(x-&gt;x.getValue()%2==1)            .findFirst()            .get()            .getKey();    }}</code></pre><p>　　我的思路是：遍历数组，构建一个哈希表，每个数为键，出现次数为值，找出其中出现次数为奇数的键。这种思路其实也很正常，就是执行时间是个问题，差点没AC。</p><p>　　其实，如果使用位运算的话，就很简单了。原理很简单：两个相同的数进行异或操作，结果为0；一个数与0进行异或运算，结果仍是这个数。所以，这题可以这么做：</p><pre><code>import java.util.Arrays;public class FindOdd {    public static int findIt(int[] A) {        return Arrays.stream(A).reduce(0, (x,y)-&gt;x^y);//awesome!    }}</code></pre><p>　　优劣一下子就看出来了。</p><p>　　下面给出一些各种位运算的常见用途：</p><ul><li><code>与(&amp;)</code> 与运算，当相同位都为1时，结果为1。<ul><li>判断奇偶性。<code>n&amp;1</code>，结果为1是奇数，结果为0是偶数，这种比n%2要快。</li><li>判断是否是2的幂。<code>n&amp;(n-1)</code>，结果为0，是2的幂，否则不是。</li><li>求二进制中1出现的次数。<code>for(int time=0;x!=0;x&amp;=x-1)time++</code>，time就是出现的次数。</li><li>销毁数据（辗转地与0运算）。</li><li>保留二进制中特定的位。<code>n&amp;0100</code>，保留第三位。</li></ul></li><li><code>或(|)</code> 或运算，当相同位有一个为1时，结果为1。<ul><li>设置二进制中特定的位。<code>n|0100</code>，设置第三位为1。</li><li>上面说的权限叠加。</li></ul></li><li><code>非(~)</code> 每个位取反。<ul><li>求绝对值。对于负数，取反加一。</li></ul></li><li><code>异或(^)</code> 相同位上，值相同，结果为0，不同则为1。<ul><li>计算出现奇数次的数。</li><li>交换两个数。<code>a=a^b;b=b^a;a=a^b;</code>，交换a和b的值。</li><li>简单的对称加密。与密钥（一个整数）异或，得到密文，再次异或，得到明文。</li></ul></li><li><code>移位(&lt;&lt;和&gt;&gt;)</code> 将每个位左移或者右移，超出的以0填充。<ul><li>乘以或者除以2的幂。</li><li>快速求2的幂的模。<code>n&amp;((1&lt;&lt;k)-1)</code>，就是和<code>2^k-1</code>（k个1）进行与运算。</li></ul></li></ul><p>　　暂时就举这么多例子了，想不出来了。可以阅读《编程珠玑》或者《数学之美》，里面有很多这种技巧。</p><h1 id="Java的EnumSet"><a href="#Java的EnumSet" class="headerlink" title="Java的EnumSet"></a>Java的EnumSet</h1><p>　　在前面提到过，安卓的SDK中经常可以见位掩码，据说是因为枚举占用的空间比较多，所以不用枚举，但在实际开发中，并不需要像基本库那样考虑存储效率（如果这点空间都需要考虑，那就应该反思整体的设计了）。其实在Java的基本库中，有一个将枚举和位掩码结合的类，那就是<code>java.util.EnumSet</code>。</p><p>　　其实阅读过《Effective Java》的人应该有印象，第六章的第30、32条提到过，应该避免使用int型的常量、位域，而应该使用枚举、EnumSet代替。</p><p>　　EnumSet是一个抽象类，它会根据枚举中的个数，返回不同的实现，以下是它的部分源码：</p><pre><code>/** * Creates an empty enum set with the specified element type. * * @param &lt;E&gt; The class of the elements in the set * @param elementType the class object of the element type for this enum *     set * @return An empty enum set of the specified type. * @throws NullPointerException if &lt;tt&gt;elementType&lt;/tt&gt; is null */public static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; noneOf(Class&lt;E&gt; elementType) {    Enum&lt;?&gt;[] universe = getUniverse(elementType);    if (universe == null)        throw new ClassCastException(elementType + &quot; not an enum&quot;);    if (universe.length &lt;= 64)        return new RegularEnumSet&lt;&gt;(elementType, universe);    else        return new JumboEnumSet&lt;&gt;(elementType, universe);}</code></pre><p>　　阅读EnumSet的源码就可以发现，其实EnumSet还是使用了位掩码的。以下是<code>RegularEnumSet</code>的添加和删除操作的源码。</p><pre><code>/** * Adds the specified element to this set if it is not already present. * * @param e element to be added to this set * @return &lt;tt&gt;true&lt;/tt&gt; if the set changed as a result of the call * * @throws NullPointerException if &lt;tt&gt;e&lt;/tt&gt; is null */public boolean add(E e) {    typeCheck(e);    long oldElements = elements;    elements |= (1L &lt;&lt; ((Enum&lt;?&gt;)e).ordinal());    return elements != oldElements;}/** * Removes the specified element from this set if it is present. * * @param e element to be removed from this set, if present * @return &lt;tt&gt;true&lt;/tt&gt; if the set contained the specified element */public boolean remove(Object e) {    if (e == null)        return false;    Class&lt;?&gt; eClass = e.getClass();    if (eClass != elementType &amp;&amp; eClass.getSuperclass() != elementType)        return false;    long oldElements = elements;    elements &amp;= ~(1L &lt;&lt; ((Enum&lt;?&gt;)e).ordinal());    return elements != oldElements;}</code></pre><p>　　从中可以明白，为什么是长度大于<code>64</code>时返回的实现是<code>JumboEnumSet</code>。因为在<code>RegularEnumSet</code>中，使用64位的long实现位掩码，所以大于64个时，使用的是另一个实现。然而，<code>JumboEnumSet</code>也是使用位掩码，只是它内部是通过一个long型数组实现的。</p><pre><code>/** * Bit vector representation of this set.  The ith bit of the jth * element of this array represents the  presence of universe[64*j +i] * in this set. */private long elements[];</code></pre><p>　　所以推荐在java中需要使用位掩码时，使用EnumSet来代替整型常数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　位运算符有很多，例如与(&amp;amp;)、或(|)、非(~)、异或(^)、移位(&amp;lt;&amp;lt;和&amp;gt;&amp;gt;)等。几乎每种语言都提供了对位运算的支持，但是，这些运算符在日常的编程中很少会用到（Ｃ语言中倒是经常可以看到，特别是在嵌入式开发中，最近看的一个智能卡系统中，几
      
    
    </summary>
    
      <category term="奇技淫巧" scheme="https://w-angler.com/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"/>
    
    
      <category term="C" scheme="https://w-angler.com/tags/C/"/>
    
      <category term="Java" scheme="https://w-angler.com/tags/Java/"/>
    
      <category term="位掩码" scheme="https://w-angler.com/tags/%E4%BD%8D%E6%8E%A9%E7%A0%81/"/>
    
      <category term="EnumSet" scheme="https://w-angler.com/tags/EnumSet/"/>
    
  </entry>
  
  <entry>
    <title>JVM类加载与一些使用技巧</title>
    <link href="https://w-angler.com/2016/10/28/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <id>https://w-angler.com/2016/10/28/JVM类加载与一些使用技巧/</id>
    <published>2016-10-27T17:31:10.000Z</published>
    <updated>2018-04-01T16:17:31.703Z</updated>
    
    <content type="html"><![CDATA[<p>　　JVM提供了强大的类加载机制，使得在java程序运行时，可以动态地加载、卸载不同的类。JVM提供了三种不同的类加载器，我们也可以继承ClassLoader来实现自己的类加载器（Tomcat实现了自己的类加载器来加载不同应用的依赖）。这给了我们很大的灵活性，而且利用类加载时的初始化动作，可以实现一些很有趣的技巧。</p><h1 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h1><p>　　<code>定义</code>：JVM把类文件加载到内存，并进行字节码校验、数据转换和解析、类初始化等操作，最终形成可以被虚拟机直接使用的java类型的过程。</p><p>　　JVM的一个特性是，它不是启动时把所有的<code>.class</code>文件加载到内存中，而是采取动态加载的方式，延迟到需要时再加载（类似Windows程序的动态链接库），而当JVM中不存在某个类的Class对象的引用时，则这个类将会被卸载。</p><p>　　根据<code>JVM规范</code>第五章（地址：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html" target="_blank" rel="noopener">Chapter 5. Loading, Linking, and Initializing</a>），类加载的过程可以表示为下图（原谅我用visio随便画的丑图），图中有一定的顺序，但是有些阶段JVM规范并未规定一定要这样，这里只是直观上的顺序：</p><p><img src="1.png" alt="Loading, Linking, and Initializing"></p><p>　　接下来一一讲解一下每个过程：</p><ul><li><code>加载(Loading)</code>　通过类的全限定名获取此类的二进制字节流→<br>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构→在堆中生成一个代表这个类的java.lang.Class对象作为方法区这些数据的访问入口。加载部分可以通过JVM自带的类加载器完成，也可以通过用户自定义的类加载器完成，由此，用户可以在这个阶段进行很多的定制，例如在<code>Tomcat</code>中自定义了类加载器，加载<code>WEB-INF/lib</code>和<code>WEB-INF/classes</code>下的类。</li><li><code>验证(Verification)</code>　连接阶段的第一步，确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。在JVM规范中，这个部分只有很简略笼统的描述（几行，只规定了在验证错误时需要抛出<code>java.lang.VerifyError</code>），所以具体实现依赖于JVM的实现，但一般都会进行这些操作：<ul><li>文件格式验证：验证字节流是否符合JVM规范，并且要满足当前JVM的版本运行需求；</li><li>元数据验证：进行语义分析，验证字节流内容是否符合Java规范；</li><li>字节码验证：数据流、控制流分析，保证语义合法、合乎逻辑；</li><li>符号引用验证：在将符号引用转化为直接引用时，验证合法性，保证解析阶段的正确性。</li></ul></li><li><code>准备(Preparation)</code>　为类变量（static修饰）分配内存并设置初始值。这里的初始值并不是初始化的值，而是该变量的数据类型的默认零值。但有一个例外，如果这个类变量同时也被final修饰，那么在编译时，就会直接为这个常量赋上目标值。</li><li><code>解析(Resolution)</code>　虚拟机将常量池中的符号引用替换为直接引用，JVM规范中，规定的解析动作有:<ul><li>类或接口解析</li><li>类字段解析</li><li>类方法解析</li><li>接口方法解析</li><li>方法类型和方法句柄解析</li><li>调用现场符号（Call site specifier）解析</li></ul></li><li><code>访问控制(Access Control)</code>　根据访问控制符（<code>public</code>、<code>protected</code>、<code>private</code>以及默认的包访问权限），限制方法调用和子类的方法重写等的访问权限。</li><li><code>覆盖(Overriding)</code>　子类覆写父类方法（根据JVM实现，在<code>虚函数表</code>中指向子类的方法入口）。</li><li><code>初始化(Initialization)</code>　执行类构造器的<code>&lt;clinit&gt;()</code>方法，进行类变量和其他资源的初始化。Java虚拟机规范规定了有<code>6</code>种情况必须立即对类进行初始化（加载、验证、准备必须在此之前完成）:<ul><li>调用<code>new</code>、<code>getstatic</code>、<code>putstatic</code>、<code>invokestatic</code>指令时（使用new关键字创建对象、读取类的静态字段、设置类的静态字段、调用类的静态方法）；</li><li>当使用Java 7增加的动态语言支持时，如果一个<code>java.lang.invoke.MethodHandle</code>实例最终的解析结果为<code>REF_getStatic</code>、<code>REF_putStatic</code>、<code>REF_invokeStatic</code>的方法句柄，并且这个方法句柄对应的类没有进行初始化时；</li><li>通过反射机制对类进行调用，其未被初始化时；</li><li>初始化一个类，其父类未初始化时，初始化父类；</li><li>初始化实现了包含<code>非抽象</code>、<code>非静态</code>方法的接口的类时（对比了一下，这个应该是Java 8增加的，应该是指<code>default方法</code>）；</li><li>指定的执行主类（含main方法的那个类）在虚拟机启动时。</li></ul></li><li><code>使用(Using)</code>　在JVM中使用加载好的类。</li><li><code>卸载(Unloading)</code>　当JVM中不存在某个类的Class对象的引用时，则这个类将会被卸载。</li><li><code>连接(Linking)</code>　包含验证、准备、解析、访问控制、覆盖阶段。</li></ul><h1 id="类加载器（ClassLoader）"><a href="#类加载器（ClassLoader）" class="headerlink" title="类加载器（ClassLoader）"></a>类加载器（ClassLoader）</h1><p>　　类加载器是一个用来加载类文件的Java类或者JVM中的C++程序，在运行时动态加载所需的类。类加载器可以加载文件系统、网络或其他来源的类文件，就是说，不管你的类在哪，只要类加载器能够得到它的字节流（无论是文件读取、网络下载），就能被加载到JVM中。</p><p>　　在JVM中，有三类默认的类加载器：</p><ul><li><p><code>Bootstrap类加载器</code>　它负责加载虚拟机的核心类库，如java.lang.*等。它是所有类加载器的父加载器。Bootstrap类加载器没有任何父类加载器，它依赖于底层操作系统，属于虚拟机的实现的一部分，它并没有继承java.lang.ClassLoader类。</p></li><li><p><code>Extension类加载器</code>将类加载请求先委托给它的父加载器，也就是Bootstrap类加载器，如果没有成功加载的话，再从<code>jre/lib/ext</code>目录下或者<code>java.ext.dirs</code>系统属性定义的目录下加载类。在oracle的JVM实现里，是<code>sun.misc.Launcher$AppClassLoader</code>类，继承自java.lang.ClassLoader类，</p></li><li><p><code>Application类加载器</code>　也叫System类加载器。它负责从<code>CLASSPATH</code>环境变量中加载某些应用相关的类，CLASSPATH环境变量通常由-classpath或-cp命令行选项来定义，或者是JAR中的Manifest的classpath属性。Application类加载器是Extension类加载器的子加载器。在oracle的JVM实现里，是<code>sun.misc.Launcher$ExtClassLoader</code>类，继承自java.lang.ClassLoader类。</p></li></ul><p>　　除了以上的三种类加载器，还有一种比较特殊的类型，线程上下文类加载器，这里就不赘述，可以查看这篇博客：<a href="http://blog.csdn.net/zhoudaxia/article/details/35897057" target="_blank" rel="noopener">线程上下文类加载器</a> 。</p><p>　　然而，类加载这个部分有趣的地方，并不是这些自带的类加载器，而是那些可以自己定制的地方。因为类加载器并不管字节流的来源，只要能通过验证就可以了。所以，你可以通过自定义的类加载器，从互联网的任何一个地方加载一个类到你本地的JVM中；你可以加载经过加密的字节码，在加载的过程中解密，如果是经过非对称加密（<code>RSA</code>、<code>ECC</code>等）的话，便可以让不信任的人无法运行加密过的Java程序；你可以在运行时，根据环境、需求的不同，加载不同的类到JVM中；你还可以通过使用不同的类加载器加载同一个类文件，这样可以产生一些神奇的效果——这个类文件的两次加载产生的类是不同的；……</p><p>　　类加载还有一个<code>双亲委托机制</code>，就是，当加载一个类时，类加载器的调用顺序是Bootstrap类加载器→Extension类加载器→Application类加载器→自己定义的类加载器。这样，形成了一个树状结构，除了<code>Bootstrap类加载器</code>外，都有一个父节点（这个和类的继承树不一样，这里的双亲并不是继承的，有兴趣的可以查看<code>Open JDK</code>中的实现,其实很简单，链接：<a href="http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/f7be58eb30bc/src/share/classes/java/lang/ClassLoader.java" target="_blank" rel="noopener">ClassLoader.java</a>）。当前面的类加载器加载不了，便会委托给下一级，如果都加载不了，便会抛出<code>ClassNotFoundException</code>。</p><p>　　实现自己的类加载器很简单，只需要继承<code>java.lang.ClassLoader</code>，并且覆盖<code>findClass</code>或者<code>loadClass</code>方法就好了。你可能会问，为什么会有俩个覆盖选择？这个就涉及到java的兼容性黑历史了。ClassLoader在Java最初的版本中就有了，但是，委托机制是在1.2才加入的，在此之前，自定义类加载器是通过覆盖<code>loadClass</code>实现的，而之后，为了兼容性，便加入了<code>findClass</code>来供用户覆盖，这样就可以保证委托机制。区别在于，覆盖<code>loadClass</code>方法，加载时不会委托，而覆盖<code>findClass</code>则会先委托，加载不了再通过自定义加载器加载。现在不建议通过覆盖<code>loadClass</code>的方法来实现。这个委托机制其实还有一些问题，这里就不细说了，具体可以搜索<code>Java模块化</code>方面的信息。</p><p>　　接下来我们通过一个简单的例子来理解：</p><p><code>MyLoader.java</code></p><pre><code>import java.io.FileInputStream;import java.nio.ByteBuffer;import java.nio.channels.FileChannel;/** * 自定义类加载器，为了简单，加载一个特定的类。&lt;br&gt; * 自定义必须覆盖&lt;code&gt;findClass&lt;/code&gt;或者&lt;code&gt;loadClass&lt;/code&gt;方法。 * @author w-angler * */public class MyLoader extends ClassLoader {    /**     * 获取字节流，假设在F盘下有一个hhh.class     * @param name     * @return     */    private byte[] load(){        try(FileInputStream is=new FileInputStream(&quot;F:\\hhh.class&quot;)){            FileChannel channel=is.getChannel();            ByteBuffer buffer=ByteBuffer.allocate((int)channel.size());            channel.read(buffer);            return buffer.array();        }catch(Exception e) {            e.printStackTrace();            return null;        }    }    @Override    public Class&lt;?&gt; findClass(String name){        byte[] b=load();        return defineClass(&quot;hhh&quot;,b, 0, b.length);    }}</code></pre><p><code>TestClassLoader.java</code></p><pre><code>import javax.script.ScriptEngine;import javax.script.ScriptEngineManager;public class TestClassLoader {    public static void main(String[] args) throws Exception {        //Nashorn是Java 8添加的JavaScript引擎，它在ext目录下        ScriptEngineManager scriptEngineManager = new ScriptEngineManager();         ScriptEngine nashorn = scriptEngineManager.getEngineByName(&quot;nashorn&quot;);        MyLoader loader=new MyLoader();        Class&lt;?&gt; cls=loader.loadClass(&quot;2333，这个参数其实没用了&quot;);        System.out.println(String.class.getClassLoader());        System.out.println(nashorn.getClass().getClassLoader());        System.out.println(TestClassLoader.class.getClassLoader());        System.out.println(cls.getClassLoader());    }}</code></pre><p><code>结果：</code></p><pre><code>nullsun.misc.Launcher$ExtClassLoader@42a57993sun.misc.Launcher$AppClassLoader@73d16e93MyLoader@64bf3bbf </code></pre><p>　　从结果可以看出，基本库中的类通过<code>Bootstrap类加载器</code>加载，所以输出为null；在ext目录下的类，通过<code>Extension类加载器</code>加载；在classpath中的类，通过<code>Application类加载器</code>；当这些类都无法加载时，采用自定义的类加载器（如果有）加载。</p><h1 id="类加载时的初始化"><a href="#类加载时的初始化" class="headerlink" title="类加载时的初始化"></a>类加载时的初始化</h1><p>　　在类加载时，会进行一些初始化的操作，前面提到过，在<code>准备(Preparation)</code>阶段，会进行一些初始化操作，初始化类变量为零值。而在后续的初始化中，则会对静态变量赋值，并且执行其中的<code>静态块</code>（<code>static</code>关键字声明的代码块）。这部分的初始化只会在类加载时执行，且只执行一次。</p><p>　　而在创建一个类的对象时，也会进行一些初始化操作。下面结合这个来说明一下一个类从加载到创建一个对象，初始化的顺序：</p><ol><li>父类静态变量和静态块，按声明的顺序依次执行（只在类加载时执行一次）。</li><li>子类静态变量和静态初始化块，按声明的顺序依次执行（只在类加载时执行一次）。</li><li>父类的实例变量和实例初始化块，按在代码中出现的顺序依次执行。</li><li>执行父类的构造方法。</li><li>子类实例变量和实例初始化块，按在代码中出现的顺序依次执行。</li><li>执行子类的构造方法。 </li></ol><p>　　下面实践一下：</p><pre><code>class A{    static{        System.out.println(&quot;super class&#39; static block&quot;);    }    {        System.out.println(&quot;super class&#39; initialization block&quot;);    }    public A(){        System.out.println(&quot;super class&#39; constructor&quot;);    }}class B extends A{    static int i;    static{        System.out.println(&quot;subclass&#39; static block&quot;);        System.out.println(i);    }    static{        i=233;    }    {        System.out.println(&quot;subclass&#39; initialization block&quot;);    }    public B(){        System.out.println(&quot;subclass&#39; constructor&quot;);    }}public class Init {    public static void main(String[] args){        new B();    }}</code></pre><p>　　结果：</p><pre><code>super class&#39; static blocksubclass&#39; static block0super class&#39; initialization blocksuper class&#39; constructorsubclass&#39; initialization blocksubclass&#39; constructor</code></pre><p>　　由此可见初始化的顺序是怎样的。其中，在子类<code>B</code>中，打印<code>i</code>的代码块在赋值之前，所以，打印出来的是在准备阶段初始化的零值，而不是233。</p><h1 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h1><p>　　其实也说不上什么技巧，只是对类加载机制的一些应用。</p><p>　　第一个，在基本库中，有几个自定义的类加载器，其中，有一个叫<code>java.net.URLClassLoader</code>，可以通过它来加载指定目录下的类。这样，就可以不需要在运行时指定classpath了，而是可以放在某个目录下，自定义加载，实现类似于插件的功能（Eclipse好像就是使用这种方式的）。具体可以查看这篇博客：<a href="http://www.iteye.com/topic/1113190" target="_blank" rel="noopener">class文件的动态加载</a>。</p><p>　　第二个，在类加载时，进行字节流的解密（加载的是加密过的class文件）。这个技巧有点黑暗了，主要是因为Java很容易被反编译。如果是一些商业机密程序，被人获取的话，很容易被反编译然后被利用。所以，可以通过这种方式，来防止被第三方利用。而加密算法的选择和密钥的存储、分发，就不在这里的讨论范围了。</p><p>　　第三个，我经常使用的，使用静态块进行配置文件的加载和初始化，实现程序的可配置。在Web开发以及一些桌面程序开发中，都会有很多的配置，这最忌讳的就是硬编码到代码中，所以一般会有很多的配置文件（一般是<code>.ini</code>和<code>.xml</code>文件，java中有一个专门干这个的<code>.properties</code>文件以及<code>java.util.Properties</code>类，最近也看到有很多用json做为配置文件和模板的）。而这个配置文件的加载也是一个问题，首先，只加载一次，其次，最好不要手动加载。所以，一个解决方法是，将配置文件的加载和解析放在静态块中，下面是我以前写的武大教务爬虫的一个配置：</p><pre><code>import java.io.FileInputStream;import java.io.IOException;import java.util.Properties;import org.junit.Test;public final class Address {    public static String ip;    /**     * 验证码地址     */    public static String captcha;    /**     * 登录地址     */    public static String login;    /**     * 成绩单地址     */    public static String subjects;    /**     * 首页,获取姓名     */    public static String name;    static{        try {            FileInputStream in=new FileInputStream(&quot;ip.properties&quot;);            Properties prop=new Properties();            prop.load(in);            ip=prop.getProperty(&quot;ip&quot;);            captcha=&quot;http://&quot;+ip+&quot;/servlet/GenImg&quot;;            login=&quot;http://&quot;+ip+&quot;/servlet/Login&quot;;            subjects=&quot;http://&quot;+ip+&quot;/servlet/Svlt_QueryStuScore?year=0&amp;term=&amp;learnType=&amp;scoreFlag=0&quot;;            name=&quot;http://&quot;+ip+&quot;/stu/stu_index.jsp&quot;;        } catch (IOException e) {            e.printStackTrace();        }    }    private Address(){        throw new IllegalAccessError(&quot;You can not new an instance of this class&quot;);    }}</code></pre><p>　　在这个代码中，主要配置的是教务管理系统的IP（有多个，经常会抽风），可以直接通过Address来引用这些配置。当然，这个是很简单的配置，你也可以实现一些更复杂的。</p><hr><p>　　这篇博客从周一开始写，因为课程、作业的问题，一直没有完成，到最后当初的热情和想法都没了，有些地方自己都看不下去了。</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　JVM提供了强大的类加载机制，使得在java程序运行时，可以动态地加载、卸载不同的类。JVM提供了三种不同的类加载器，我们也可以继承ClassLoader来实现自己的类加载器（Tomcat实现了自己的类加载器来加载不同应用的依赖）。这给了我们很大的灵活性，而且利用类加载
      
    
    </summary>
    
      <category term="JVM" scheme="https://w-angler.com/categories/JVM/"/>
    
    
      <category term="Java" scheme="https://w-angler.com/tags/Java/"/>
    
      <category term="JVM" scheme="https://w-angler.com/tags/JVM/"/>
    
      <category term="虚拟机" scheme="https://w-angler.com/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>第三章——antlr小试牛刀</title>
    <link href="https://w-angler.com/2016/10/18/%E7%AC%AC%E4%B8%89%E7%AB%A0%E2%80%94%E2%80%94antlr%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80/"/>
    <id>https://w-angler.com/2016/10/18/第三章——antlr小试牛刀/</id>
    <published>2016-10-18T13:44:48.000Z</published>
    <updated>2018-04-01T11:08:35.972Z</updated>
    
    <content type="html"><![CDATA[<p>　　接下来开始我们的第一个入门项目。</p><p>　　我们会构建<code>C</code>或者它的派生语言如<code>Java</code>的一个语法子集。详细点说，就是识别像<code>{1,2,3}</code>或者<code>{1,{2,3},4}</code>这样的由大括号包围（或嵌套）的整数。这个结构可能是整数数组，也有可能是结构体的初始化。这个语法在很多情况下都是很有用的，例如，我们可以用它来构建一个用来将<code>int数组</code>转换为<code>字节数组</code>（如果数组的所有初始值大小都在一个字节内的话）的C语言源码重构工具。我们也可以用这个语法来将Java的<code>short数组</code>转换为字符串，例如，我们可以将下面的代码：</p><pre><code>static short[] data = {1,2,3};</code></pre><p>　　转化为：</p><pre><code>static String data = &quot;\u0001\u0002\u0003&quot;; // Java的字符是无符号的short</code></pre><p>　　<code>Unicode</code>使用四个十六进制位来表示16位（short的长度）的字符值，例如<code>\u0001</code>。</p><p>　　我们之所以要做这个转换，是因为，在Java的<code>.class</code>文件中，存在一些限制。在Java的<code>.class</code>文件中，数组的初始化是像<code>data[0]=1;data[1]=2; data[2]=3;</code>这样的显式赋值初始化，而不是一个包含初始化数据的紧凑代码块。因为Java规范中限制了初始化方法的大小，所以数组的初始大小也被限制了。而不同的是，在Java<code>.class</code>文件中，字符串是以连续的<code>short</code>序列的形式存储的，所以，将数组转换为字符串可以生成更紧凑的<code>.class</code>文件，并且突破初始化方法的大小限制。</p><p>　　通过这个入门项目，你将会学习，antlr的<code>语法定义</code>语法，它将语法文件生成了哪些东西，如何将在Java程序中包含antlr生成的语法分析器代码，以及如何使用监听器来构建一个翻译器。</p><h2 id="3-1-antlr的工具、运行时，以及生成的代码"><a href="#3-1-antlr的工具、运行时，以及生成的代码" class="headerlink" title="3.1 antlr的工具、运行时，以及生成的代码"></a>3.1 antlr的工具、运行时，以及生成的代码</h2><p>　　开始之前，我们先来剖析一下antlr的jar包。在antlr中，有两个重要的组件：<code>antlr生成工具</code>和<code>运行时</code>。当我们“在一个语法上运行antlr”时，我们是在讨论<code>antlr生成工具</code>，<code>org.antlr.v4.Tool</code>类，它将会生成可以识别符合语法的句子的程序代码（词法分析器和语法分析器）。词法分析器将输入的字符流解析为token并且将它们传递给语法分析器来检查语法正确性。而<code>运行时</code>是生成的语法分析器、词法分析器、token在运行时所需要的类库和方法。我们先运行antlr生成工具来生成代码，然后编译它们，最后，在antlr的运行时中运行生成的代码。</p><p>　　在我们构建一个语言应用之前，我们必须先编写描述语法规则的语法文件。我们会在第五章详细学习如何来编写语法，但是在此之前，我还是先给出我们接下来所需要的语法描述：</p><p><code>ArrayInit.g4</code></p><pre><code>/*语法文件都由一个语法头开始，它指定了语法的名称，而且语法名称必须和文件名相同。 * 在这个例子中，语法名称是ArrayInit，文件名为ArrayInit.g4 */grammar ArrayInit;/* init将匹配在大括号中，由英文逗号分割的值。*/init : &#39;{&#39; value (&#39;,&#39; value)* &#39;}&#39; ; // 匹配至少一个值/*值可以是整数，也可以是嵌套的数组*/value : init | INT ;//语法规则由小写字母开头，词法规则由大写字母开头INT : [0-9]+ ; //定义整数WS : [ \t\r\n]+ -&gt; skip ; // 忽略空白符</code></pre><p>　　将<code>ArrayInit.g4</code>文件放在一个单独的文件夹下，例如<code>/tmp/array</code>。然后，运行antlr生成工具：</p><pre><code>$ cd /tmp/array $ antlr4 ArrayInit.g4 # 使用之前设置的别名运行antlr生成工具</code></pre><p>　　随后，我们会发现，在此目录下，antlr为<code>ArrayInit.g4</code>这个语法生成了很多个文件：</p><p><img src="2016-10-18_458FD8E8F4603041BF512E69EE4F012B.png" alt=""></p><p>　　于此，我们对开发的流程有了一个大致了解。接下来让我们来了解一下这些生成的文件：</p><ul><li><code>ArrayInitParser.java</code> 这个文件包含了为了<code>ArrayInit</code>这个语法生成的语法分析器，它包含对应每一个语法规则的函数以及一些其他的支持代码。</li><li><code>ArrayInitLexer.java</code> antlr会自动从语法文件中分离出词法和语法。这个文件包含了<code>ArrayInit</code>的词法定义，<code>INT</code>、<code>WS</code>以及字面值如<code>{</code>、<code>,</code>和<code>}</code>。记住，词法分析器的作用是将输入解析为token。</li><li><code>ArrayInit.tokens</code> antlr会为我们定义的token类型赋予一个类型数，并且将它们存储在这个文件中。当我们需要将一个很复杂的语法分解为多个小语法时，为了同步所有的token类型，这个文件是很有必要的。</li><li><code>ArrayInitListener.java</code>、<code>ArrayInitBaseListener.java</code> 默认地，antlr会为输入构建一个语法分析树。通过遍历这个树，遍历器可以触发我们提供的监听器对象的回调方法。<code>ArrayInitListener</code>是这些回调方法的接口，而<code>ArrayInitBaseListener</code>是<code>ArrayInitListener</code>的空实现，通过继承这个类，我们可以只覆盖我们感兴趣的回调方法。antlr也可以通过添加<code>-visitor</code>命令行参数生成<code>Visitor</code>（见上一章）。</li></ul><p>　　我们会在后面使用监听器类来将short数组转换为字符串对象，但是，在此之前，我们要确认一下，这个生成的语法分析器是否可以识别一些简单的输入。</p><hr><blockquote><h3 id="antlr的语法描述能力比正则式强大得多"><a href="#antlr的语法描述能力比正则式强大得多" class="headerlink" title="antlr的语法描述能力比正则式强大得多"></a><strong>antlr的语法描述能力比正则式强大得多</strong></h3></blockquote><blockquote><p>熟悉正则式（维基百科：<a href="https://zh.wikipedia.org/zh/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F" target="_blank" rel="noopener">正则表达式</a>）的人可能会有疑问，用antlr来解决如此简单的识别问题，是不是有点大材小用了。但事实是，因为存在嵌套，我们并不能使用正则式来识别这个数组初始化的例子。正则式是无记忆的，因为它不能回想起它之前识别过的输入。因此，正则式不知道怎么识别左右两边的大括号。</p></blockquote><hr><h2 id="3-2-测试生成的语法分析器"><a href="#3-2-测试生成的语法分析器" class="headerlink" title="3.2 测试生成的语法分析器"></a>3.2 测试生成的语法分析器</h2><p>　　在开始测试之前，我们必须先编译这些生成的Java源代码。我们可以直接编译在<code>/tmp/array</code>下的所有文件：</p><pre><code>$ cd /tmp/array $ javac *.java #编译生成的语法分析器</code></pre><p>　　如果你编译时出现了<code>ClassNotFoundException</code>错误，这就意味着你可能没有设置好Java的<code>CLASSPATH</code>环境变量。在<code>UNIX</code>系统中，你需要执行以下的命令（你也可以添加到shell的启动脚本中，例如<code>.bash_profile</code>）：</p><pre><code>$ export CLASSPATH=&quot;.:/usr/local/lib/antlr-4.0-complete.jar:$CLASSPATH&quot;</code></pre><p>　　为了测试我们的语法，我们使用在之前的章节中设置的<code>TestRig</code>的别名<code>grun</code>。下面使用它来打印词法分析器识别出的token：</p><pre><code>$ grun ArrayInit init -tokens{99, 3, 451}EOF[@0,0:0=&#39;{&#39;,&lt;1&gt;,1:0][@1,1:2=&#39;99&#39;,&lt;4&gt;,1:1][@2,3:3=&#39;,&#39;,&lt;2&gt;,1:3][@3,5:5=&#39;3&#39;,&lt;4&gt;,1:5][@4,6:6=&#39;,&#39;,&lt;2&gt;,1:6][@5,8:10=&#39;451&#39;,&lt;4&gt;,1:8][@6,11:11=&#39;}&#39;,&lt;3&gt;,1:11][@7,13:12=&#39;&lt;EOF&gt;&#39;,&lt;-1&gt;,2:0]</code></pre><p>　　在输入<code>{99,3,451}</code>后，我们必须再输入EOF（unix:<code>ctrl+D</code>;windows:<code>ctrl+Z</code>）。默认地，antlr会在处理之前加载整个输入（通常来说，这个是效率最高的方法）。</p><p>　　输出的每一行代表一个token，它展示了这个token的所有信息。例如，<code>[@5,8:10=&#39;451&#39;,&lt;4&gt;,1:8]</code>表示：这个token的索引为<code>5</code>（起始为<code>0</code>），文本内容为<code>451</code>，是第<code>8</code>到<code>10</code>个字符（索引也由0开始），token类型是<code>4</code>（INT），在第一行（从<code>1</code>开始），第<code>8</code>列（从0开始，<code>tab</code>算做一个单独的字符）。可以看到，并没有空格和换行符的token，因为我们的语法中，<code>WS</code>声明将它们忽略（-&gt;skip）。</p><p>　　为了更详细地了解语法分析器是怎样识别的，我们可以在运行时加上<code>-tree</code>参数：</p><pre><code>$ grun ArrayInit init -tree{99, 3, 451}EOF(init { (value 99) , (value 3) , (value 451) })</code></pre><p>　　加上<code>-tree</code>参数将会以Lisp风格输出语法分析树。又或者，加上<code>-gui</code>参数，在一个对话框中可视化语法分析树。我们用一个嵌套的数组作为输入：</p><pre><code>$ grun ArrayInit init -gui{1,{2,3},4}EOF</code></pre><p>　　下面就是弹出的语法分析树对话框：</p><p><img src="2016-10-18_815EDCD7646FED15569D147F9F3B3DA1.png" alt=""> </p><p>　　语法树可以说人话的话，它就是在说“这个输入是用大括号包围的包含三个值的数组初始化，第一个和第三个值是整数<code>1</code>和<code>4</code>，第二个值也是一个数组，它包含两个值，值为<code>2</code>和<code>3</code>”。</p><p>　　这些内部节点，例如<code>init</code>和<code>value</code>，通过名称来识别各种各样的输入，就像，在英语句子中识别动词和主语。antlr会基于我们语法文件中的语法规则自动为我们构建语法分析树，在这章的末尾，我们会利用antlr内置的遍历器触发像<code>enterInit()</code>和<code>enterValue()</code>这样的回调方法来构建一个翻译器。</p><p>　　现在，既然我们已经学会了如何用antlr来测试语法，那么我们就开始学习如何在Java程序中调用这个生成的语法分析器吧！</p><h2 id="3-3-将生成的语法分析器集成进Java程序"><a href="#3-3-将生成的语法分析器集成进Java程序" class="headerlink" title="3.3 将生成的语法分析器集成进Java程序"></a>3.3 将生成的语法分析器集成进Java程序</h2><p>　　有了先前的良好开始后，我们就可以将antlr生成的语法分析器集成进一个更大程序中了。在这节，我们将会学习一个在Java程序中使用<code>main方法</code>调用语法分析器并且打印像<code>TestRig</code>添加<code>-tree</code>参数的输出的简单程序。以下这个<code>Test.java</code>文件大致体现出了第二章第一节的那个数据流图：</p><p><code>Test.java</code></p><pre><code>//导入antlr的运行时库import org.antlr.v4.runtime.*; import org.antlr.v4.runtime.tree.*;public class Test {    public static void main(String[] args) throws Exception {         //创建一个读取标准输入的CharStream        ANTLRInputStream input = new ANTLRInputStream(System.in);        //创建一个从指定的CharStream中读取数据的词法分析器        ArrayInitLexer lexer = new ArrayInitLexer(input);        //创建一个词法分析器产生的token缓冲        CommonTokenStream tokens = new CommonTokenStream(lexer);        //创建一个从token缓冲中读取token的语法分析器        ArrayInitParser parser = new ArrayInitParser(tokens);        ParseTree tree = parser.init(); //开始分析规则init        System.out.println(tree.toStringTree(parser)); // 打印Lisp风格的语法分析树    }}</code></pre><p>　　这个程序使用了一系列像<code>CommonTokenStream</code>和<code>ParseTree</code>这样的antlr运行时中的类，我们会在第四章第一节详细学习它们。</p><p>　　接下来让我们编译并运行这个程序：</p><pre><code>$ javac ArrayInit*.java Test.java$ java Test{1,{2,3},4}EOF(init { (value 1) , (value (init { (value 2) , (value 3) })) , (value 4) })</code></pre><p>　　antlr也可以自动地报告和恢复语法错误。例如，我们的输入如果少了最后一个大括号，它将会产生以下的输出：</p><pre><code>$ java Test{1,2EOFline 2:0 missing &#39;}&#39; at &#39;&lt;EOF&gt;&#39;(init { (value 1) , (value 2) &lt;missing &#39;}&#39;&gt;)</code></pre><p>　　于此，我们已经学会了如何运行antlr生成工具，如何将生成的语法分析树集成到Java程序中。如果一个程序只可以用来检查语法的话，并没有什么大不了的，因此，下面让我们来完成这个将short数组转换为字符串的翻译器。</p><h2 id="3-4-构建一个语言应用"><a href="#3-4-构建一个语言应用" class="headerlink" title="3.4 构建一个语言应用"></a>3.4 构建一个语言应用</h2><p>　　下面继续先前的例子。我们的下一个目标不仅仅是识别，而且还要做一些翻译工作。例如，将Java的short数组<code>{99,3,451}</code>翻译成<code>\u0063\u0003\u01c3</code>这样的字符串，其中<code>63</code>是<code>99</code>的十六进制表示。</p><p>　　为了超越先前的识别功能，我们必须从语法分析树中提取一些信息。最简单的方法就是，利用antlr内置的语法树遍历器，在它进行深度优先遍历时，触发一系列的回调方法。正如之前看到的，antlr自动为我们生成了一个监听器。这些监听器就像是GUI组件中的回调（例如，一个按钮可以在它被按下时触发一些事件），或者是XML文件的SAX解析器。</p><p>　　而我们需要做的，只是小小的工作：继承<code>ArrayInitBaseListener</code>，实现其中的一些方法。最简单的实现就是，在进行树遍历时，每一个监听器方法打印出翻译出来的片段。</p><p>　　使用监听器的好处就是，我们不需要自己去进行树遍历。事实上，我们甚至都不需要知道antlr运行时正在遍历语法分析树、回调我们的监听器方法。我们仅仅需要知道的是，在进入和离开某个语法规则时，会触发监听器的方法。正如我们将在第七章看到的，这种方法大大减少了我们的学习量，我们需要面对的仍然是编程时的难题，而不是句子识别时的难题。</p><p>　　开始编写这个翻译程序之前，我们要知道，如何将输入的token转换为输出的字符串。对此，我们可以先对几个有代表性的例子进行手动翻译，以此来总结转换的过程。在这个例子中，翻译的过程是非常直接的：</p><p><img src="2016-10-18_A5C23739C285BA5B161E0019A7213D20.png" alt=""></p><p>　　通俗来说，这个翻译过程就像是“X 转换为 Y”的映射规则：</p><ol><li>将<code>{</code>翻译为<code>&quot;</code>；</li><li>将<code>}</code>翻译为<code>&quot;</code>；</li><li>将整数翻译为以<code>\u</code>为前缀的四位十六进制字符串。</li></ol><p>　　为了写出这个翻译器，我们需要编写一些在碰到对应的token时可以打印出翻译结果的方法。内置的树遍历器会在进入和退出某个语法规则时触发监听器事件。下面是我们的监听器实现：</p><p><code>ShortToUnicodeString.java</code></p><pre><code>/* 将像{1,2,3}这样的数组转换为&quot;\u0001\u0002\u0003&quot; */ public class ShortToUnicodeString extends ArrayInitBaseListener {     /* 将`{`翻译为`&quot;` */     @Override     public void enterInit(ArrayInitParser.InitContext ctx) {        System.out.print(&#39;&quot;&#39;);     }    /* 将`}`翻译为`&quot;` */     @Override     public void exitInit(ArrayInitParser.InitContext ctx) {        System.out.print(&#39;&quot;&#39;);     }    /* 将整数翻译为以`\\u`为前缀的四位十六进制字符串 */     @Override     public void enterValue(ArrayInitParser.ValueContext ctx) {     // 假设没有嵌套    int value = Integer.valueOf(ctx.INT().getText());     System.out.printf(&quot;\\u%04x&quot;, value);     }}</code></pre><p>　　我们不需要覆盖每一个<code>enter/exit</code>方法，我们只需要我们关心的那些。其中，我们可能比较不熟悉的表达式是<code>ctx.INT()</code>，它代表向上下文对象请求已经匹配的整数<code>INT</code>的值。上下文对象记录了识别过程中发生的任何东西。</p><p>　　我们还需要做一件事，就是创建一个和前一节类似的主程序：</p><p><code>Translate.java</code></p><pre><code>//导入antlr的运行时库import org.antlr.v4.runtime.*; import org.antlr.v4.runtime.tree.*;public class Test {    public static void main(String[] args) throws Exception {         //创建一个读取标准输入的CharStream        ANTLRInputStream input = new ANTLRInputStream(System.in);        //创建一个从指定的CharStream中读取数据的词法分析器        ArrayInitLexer lexer = new ArrayInitLexer(input);        //创建一个词法分析器产生的token缓冲        CommonTokenStream tokens = new CommonTokenStream(lexer);        //创建一个从token缓冲中读取token的语法分析器        ArrayInitParser parser = new ArrayInitParser(tokens);        ParseTree tree = parser.init(); //开始分析规则init        // 创建一个普通的遍历器来触发监听器事件        ParseTreeWalker walker = new ParseTreeWalker();        // 遍历语法分析树，在遍历的过程中，触发回调        walker.walk(new ShortToUnicodeString(), tree);        System.out.println(); // 翻译后打印一个换行    }}</code></pre><p>　　这个程序和上一节唯一的区别是，它创建了一个树遍历器，并用它来遍历语法分析器返回的语法分析树。在它进行遍历时，它会触发在<code>ShortToUnicodeString</code>中的回调方法。</p><p>　　现在让我们来试一下这个翻译器：</p><pre><code>$ javac ArrayInit*.java Translate.java$ java Translate{99, 3, 451}EOF&quot;\u0063\u0003\u01c3&quot;</code></pre><p>　　太棒了！</p><p>　　我们刚刚构建了第一个翻译器，甚至都没怎么动语法，我们需要做的，仅仅只是实现很少的几个方法来打印合适的翻译结果。而且，我们可以通过传入不同的监听器来产生完全不同的输出！监听器将语法和我们的语言应用很大程度上解耦了，使语法具有了更大的重用性。</p><p>　　在下一章，我们会继续以走马观花的形式对antlr的<code>语法声明</code>进行一个粗略的学习，并且掌握一些使antlr变得更加强大易用的技巧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　接下来开始我们的第一个入门项目。&lt;/p&gt;
&lt;p&gt;　　我们会构建&lt;code&gt;C&lt;/code&gt;或者它的派生语言如&lt;code&gt;Java&lt;/code&gt;的一个语法子集。详细点说，就是识别像&lt;code&gt;{1,2,3}&lt;/code&gt;或者&lt;code&gt;{1,{2,3},4}&lt;/code&gt;
      
    
    </summary>
    
      <category term="Antlr" scheme="https://w-angler.com/categories/Antlr/"/>
    
    
      <category term="Antlr" scheme="https://w-angler.com/tags/Antlr/"/>
    
      <category term="Parser Generator" scheme="https://w-angler.com/tags/Parser-Generator/"/>
    
  </entry>
  
  <entry>
    <title>第二章——antlr纲要</title>
    <link href="https://w-angler.com/2016/10/16/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E2%80%94%E2%80%94antlr%E7%BA%B2%E8%A6%81/"/>
    <id>https://w-angler.com/2016/10/16/第二章——antlr纲要/</id>
    <published>2016-10-16T15:17:16.000Z</published>
    <updated>2018-04-01T11:06:14.458Z</updated>
    
    <content type="html"><![CDATA[<p>　　现在我们已经安装好了<code>antlr</code>并且知道了怎么去构建和运行一个简单的例子，接下来我们就来了解一下纲要。在这章，我们会了解语法解析的几个重要步骤，学习一些术语，并且接触相关的数据结构。在学习的过程中，我们了解会一些antlr中重要的类，以及，antlr在背后为我们做了什么。</p><h2 id="2-1-开始"><a href="#2-1-开始" class="headerlink" title="2.1 开始"></a>2.1 开始</h2><p>　　为了实现一个语言，我们必须构建一个可以读取句子，并对它所发现的短语、输入符号做出合理的动作的程序（语言由一系列合法的句子组成，句子由一系列的短语组成，短语又由子短语和字母符号组成）。概括地说，如果一个程序可以计算或者“执行”一些句子，我们就可以把它叫做“解释器”，例如计算器、配置文件的处理程序和Python的解释器；而如果我们可以用它把一种语言转换为另一种语言的话，那么我们就可以把它叫做“翻译器”，例如将Java转换为C#的翻译器，以及，我们所经常使用的<code>编译器</code>。</p><p>　　我们的解释器或者翻译器要想能够工作起来，它就必须可以识别所有合法的句子、短语、子短语。识别句子意味着它可以分辨多种不同的语法组成成分，并且将它和其他的区别开来。例如，<code>sp=100;</code>，我们可以识别出，它是编程语言中的赋值语句。这就意味着，我们知道<code>sp</code>是赋值目标，<code>100</code>是它将要储存的值（相似地，如果我们去识别英语句子的话，我们必须分辨出它的主语、谓语和宾语）。能识别像<code>sp=100;</code>这样的赋值语句，也意味着它可以明确地将它和其他的语句区别开来。而识别之后，它便可以进行一些操作，来实现这个句子体现的功能，例如<code>performAssignment(&quot;sp&quot;,100)</code>或者<code>translateAssignment(&quot;sp&quot;,100)</code>。</p><p>　　识别语法结构的程序，我们叫它语法分析器（<code>parser</code>或者<code>syntax analyzer</code>）。语法是由一系列的语法规则组成的，而语法规则是用来描述句子结构的，在这本书中，我们将会学习如何通过antlr来描述语法规则。如果不使用antlr，我们可能就需要自己动手来编写语法分析器了，这是一个经验丰富的程序员也很难做到的事，但是，有了antlr后，我们就可以直接用它来生成特定语法的分析器了。在antlr中，用来描述语法的是一种专门优化过的用来描述语法的语言：antlr的<code>元语言</code>。</p><p>　　如果我们把解析过程分为两个相似但又完全不同的阶段的话，它会变得容易理解得多。以我们阅读英语句子的过程为例（它很大程度上展示了我们大脑是怎么工作的），我们并不是一个一个字母来阅读的，而在分析句子结构之前，将一个个字母组合成单词，然后在大脑里的<code>字典</code>里查找它们的意思。这个过程在平时阅读英语时可能并没有这么明显，但是在我们阅读<code>摩尔斯电码</code>（译者注：一种早期的数字化通信形式，它的代码包括五种：点、划、点和划之间的停顿、每个字符间短的停顿（在点和划之间）、每个词之间中等的停顿以及句子之间长的停顿。<a href="http://ascii-table.com/morse-code.php" target="_blank" rel="noopener">对照表</a>）时，我们就可以明显感觉到这个过程了，因为，在从摩尔斯电码中获取信息之前，我们必须先将这些点点线线转换为字符。当然，阅读很长的单词，例如<code>Humuhumunukunukuapua’a</code>（译者注：世界上名字最长的鱼，生长在夏威夷，意思为<code>这鱼的嘴巴像猪一样</code>,<a href="https://www.zhihu.com/question/46813221/answer/111017777" target="_blank" rel="noopener">有什么生物的名字大家一听就会笑？</a>）时，这个感觉也会很明显。</p><p>　　这个将字符序列分割、组成为单词的阶段，我们叫它<code>词法分析</code>，或者简单地称为<code>tokenizing</code>，而这个用来进行词法分析的程序，我们叫它<code>词法分析器（lexer）</code>。词法分析器可以将token分为不同的类型，例如<code>INT（整数）</code>、<code>ID（标识符）</code>、<code>FLOAT（浮点数）</code>等等（语法分析器只关心token的种类）。每一个token至少都必须包含两个信息：<code>token类型</code>和<code>字符串字面值</code>。</p><p>　　而第二阶段，输入token流，并且分析出它的句子结构（在上面的例子中，是一个<code>赋值语句</code>），才是真正意义上的<code>语法分析</code>。默认地，antlr生成的语法分析器会构建一个叫做<code>语法分析树</code>的数据结构来记录语法分析器是怎样从输入的句子识别出它的结构的。举例说明，下图是一个语言程序基本的数据流：</p><p><img src="dataflow.png" alt=""></p><p>　　语法分析树的叶子都是输入的token，内部节点是短语名称，而根节点是最抽象的短语名称（在这个例子中是<code>stat</code>）。句子（线性的字符序列）和语法分析树在硬件上其实是相通的，句子其实就是一棵棵的语法分析树。为了将我们的想法传达给他人，我们必须通过单词流把幻想中语法分析树“塞进”他们脑中。</p><p>　　通过构建语法分析树，语法分析器将一个可以方便处理的数据结构传递给了语言应用程序的剩余部分，最后，剩余的部分将会从中提取出输入的句子的完整信息。在后面的步骤中，使用树形结构的好处有很多，一个是因为树形结构解析起来比较方便，而且，程序员们可以很容易地理解它。而另一个是，语法分析器可以自动地构建语法分析树。</p><p>　　通过遍历语法分析树的方式，一个语法分析器可以被多个应用程序重用。除此之外，你也可以把特定的代码片段嵌入到语法声明中（用来生成语法分析器的程序通常都会这么做）。antlr v4依然支持这种做法（查看第十章），但是，遍历语法解析树的方式更加简洁，耦合性也更低。</p><p>　　另外，在计算<code>token属性依赖</code>需要进行<code>多遍</code>（某个阶段需要前一个阶段收集的信息）的情况下，语法分析树是非常有用的。而在其他的情况下，一个应用如果太过复杂，也可以通过这种方式将其分解为一系列易于编写和测试的片段。相比于每次都重新解析输入串，对一个语法分析树进行多次遍历的效率不知道高到哪里去了。</p><p>　　因为我们通过一系列的规则来指定语法结构，所以语法分析树的子树的根节点相当于是语法规则的名称。为了提前熟悉一下我们接下来需要讲的东西，我们先看一下赋值语句的语法规则：</p><pre><code>assign : ID &#39;=&#39; expr &#39;;&#39; ; // 识别像 sp = 100; 这样的句子</code></pre><p>　　我们需要理解antlr是怎样把这样的规则翻译为可读的解析器代码的，这对于后面的使用、调试语法是非常重要的，所以，让我们深入一些，看一下语法分析的过程是怎样的。</p><h2 id="2-2-语法分析器的实现"><a href="#2-2-语法分析器的实现" class="headerlink" title="2.2 语法分析器的实现"></a>2.2 语法分析器的实现</h2><p>　　antlr通过解析像先前看到的<code>assign</code>这样的语法规则来生成<code>递归下降语法分析器</code>。<code>递归下降语法分析器</code>其实就是一系列的递归方法，每个方法对应一个语法规则。<code>下降</code>这个术语表明，分析时，我们是从树的根节点开始，逐步分析到树叶（token）的。在构建语法分析树时，我们最先调用的语法规则（<code>开始符号</code>），成为树的根节点（在上一节中，是调用<code>stat()</code>）。这种分析方法，我们叫做<code>自顶向下语法分析</code>，<code>递归下降语法分析器</code>其实就是一种自顶向下语法分析的实现。</p><p>　　为了让大家理解<code>递归下降</code>的概念，这里有一个缩减版的antlr为<code>assign</code>生成的递归方法：</p><pre><code>// 语法规则：assign : ID &#39;=&#39; expr &#39;;&#39;void assign() { //为语法规则 assign 生成的方法    match(ID); //匹配 ID    match(&#39;=&#39;);//匹配 =    expr(); // 匹配表达式 expr    match(&#39;;&#39;);//匹配 ;}</code></pre><p>　　<code>递归下降语法分析器</code>有一个很酷的地方，它调用<code>stat()</code>、<code>assign()</code>和<code>expr()</code>时的调用栈和语法分析树的内部节点是一一对应的，而<code>match()</code>方法则相当于是语法分析树的叶子节点。如果要手动构建一个语法分析树的话，我们可以在每条语法规则对应的方法前插入<code>添加新的子树根节点</code>的操作，在<code>match()</code>方法前插入<code>添加新的叶子节点</code>的操作。</p><p>　　<code>assign()</code>的功能仅仅只是确保所有需要的token都存在，并且以正确的顺序排列。当语法分析器进入<code>assign()</code>方法时，它没有其他的<code>候选项</code>（候选项是在一条语法规则中，右边的可选择项）。例如，<code>stat</code>包含了<code>assign</code>，但它也包含其他的语法规则：</p><pre><code>//匹配以下任何一种stat: assign //第一个候选项（&quot;|&quot; 是候选项的分隔符）    | ifstat //第二个候选项     | whilestat //第三个候选项    ...    ;</code></pre><p>　　像<code>stat</code>这样的语法规则对应的方法像是一个<code>switch</code>语句:</p><pre><code>void stat() {    switch ( ?当前输入token? ){        CASE ID :            assign();            break;        CASE IF :            ifstat();            break; // &quot;IF&quot;是关键字if的token类型        CASE WHILE :            whilestat();            break;        ...         default :             ?抛出异常?    }}</code></pre><p>　　如上，<code>stat()</code>方法必须通过检查下一个token的类型来决定接下来应该选择哪一个方法才可以正确解析（称作<code>预测分析</code>）。以上面为例，当看到一个<code>WHILE</code>关键字时，选择第三个候选规则，于是<code>stat()</code>调用<code>whilestat()</code>。你以前可能听过<code>前瞻符号(lookahead token)</code>（译者注：或者，向前查看符号……好难翻译啊……）这个术语，其实它就是下一个将要输入的token。</p><p>　　有时，语法分析器需要向前查看很多的token来决定该选择哪一个语法规则，甚至可能需要查看从当前位置直到文件末尾的所有token。虽然antlr默默为你处理了所有这些工作，你大可不必劳神，但是对<code>预测分析</code>有一个基本的认识的话，对接下来的学习会有很大帮助。</p><p>　　设身处地想象一下，你处在一个复杂的迷宫中，它只有一个入口和出口，并且每条路的地上都写有一些单词，从入口到出口的路上遇到的单词便组成了句子。这个迷宫的结构和语法规则其实是相似的。为了测试一个句子是否符合某个语法，我们将这个句子的每个单词和在迷宫中遇到的单词进行比较，如果最后我们能根据这个句子走出迷宫，那么这个句子就是合法的。</p><p>　　为了走出迷宫，在每个分岔路口，我们必须选择一条正确的路，就像在语法分析时的<code>预测分析</code>一样，从多个候选项中选择一个正确的。为了从中选择出正确的路，我们可以将分岔路口上可以看见的单词和我们的句子中的单词进行比较。这些分岔路上的单词，就是<code>前瞻符号</code>。如果每条路上的第一个单词都是不一样的，那么我们就可以很容易地做出选择。在规则<code>stat</code>中，每一个候选项的第一个token都不相同，所以<code>stat()</code>可以通过查看第一个前瞻符号来做出选择。</p><p>　　但是当每条分岔路的第一个单词有重叠时，语法分析器就必须向前查看更多token了，直到将每条分岔路区别开来。antlr会根据需要，在做预测分析时自动调节向前查看的token的个数。如果一直到出口（文件尾），都存在相同的前瞻符号，那么输入的句子便是具有多种解读方式的（二义性）。如何消除二义性，是我们下一节的内容。而学习完下一节之后，我们将学习如何通过语法分析树来构建语言应用。</p><h2 id="2-3-You-Can’t-Put-Too-Much-Water-into-a-Nuclear-Reactor"><a href="#2-3-You-Can’t-Put-Too-Much-Water-into-a-Nuclear-Reactor" class="headerlink" title="2.3 You Can’t Put Too Much Water into a Nuclear Reactor"></a>2.3 You Can’t Put Too Much Water into a Nuclear Reactor</h2><p>　　一个短语或者句子如果可以通过多种方式来解读，那么可以说它是具有<code>二义性</code>的。换句话说，它可以匹配多种语法（可以构建多棵不同的语法树）。本节的标题<code>You Can’t Put Too Much Water into a Nuclear Reactor</code>是一个多年前我从《周六夜现场》（译者注：一个每周六深夜播出、60多分钟的美国综艺节目，以纽约市为拍摄地，自1975年10月11日由NBC播出，是美国电视史上最长寿的节目之一）看到的具有二义性的句子，你不知道，你是应该放很多水到核反应堆中还会应该避免这么做。</p><hr><blockquote><p>译者注：</p></blockquote><blockquote><p>　　在英语中，有一个句式，<code>can not ... too much</code>，表示“再…都不为过”。同时，它也有字面上的意思，“不能太….”。所以，<code>You Can’t Put Too Much Water into a Nuclear Reactor</code>有两种解读方式，一是”你不能放太多水到核反应堆中“，还有就是”你向核反应堆中放再多水也不为过“，具有二义性，需要结合语境分析。</p></blockquote><hr><blockquote><h3 id="For-Whom-No-Thanks-Is-Too-Much"><a href="#For-Whom-No-Thanks-Is-Too-Much" class="headerlink" title=" For Whom No Thanks Is Too Much "></a><strong> For Whom No Thanks Is Too Much </strong></h3></blockquote><blockquote><p>　　我最喜欢的二义性句子之一是在我的好朋友Kevin的Ph.D论文的赠言页上：“To my Ph.D. supervisor, for whom no thanks is too much.”，你根本不清楚他是不是在感谢。Kevin说不是，所以我问他为什么博士后又跟了同一个导师，他说：“复仇。”</p></blockquote><hr><p>　　二义性在自然语言中是很有趣的，然而在编程语言中，二义性将会导致很大的问题。为了解释或者翻译一个句子，解释器或者翻译器必须能准确无误地识别它的意思。这就意味着，我们必须提供不具有二义性的语法，以确保生成的语法分析器只能以一种方式来解读输入的句子。</p><p>　　我们还没详细地学习语法的构建，但这里我们举一个具有二义性的语法来加深二义性的理解。如果在之后的开发中，你遇到了二义性的问题，你可以回过头来看这一节的内容。</p><p>　　有一些语法的二义性是非常明显的：</p><pre><code>stat: ID &#39;=&#39; expr &#39;;&#39;    | ID &#39;=&#39; expr &#39;;&#39; //嗨呀好气呀！完全一样啊！    ; expr: INT ;</code></pre><p>　　但是，通常来说，二义性是非常隐藏的，就像下面这个一样：</p><pre><code>stat: expr &#39;;&#39; //语句    | ID &#39;(&#39; &#39;)&#39; &#39;;&#39; // 函数调用    ;expr: ID &#39;(&#39; &#39;)&#39;     | INT    ;</code></pre><p>　　对于<code>f();</code>，有以下两种解读方式：</p><p><img src="f.png" alt=""></p><p>　　左边的语法匹配了第一个候选项（语句），右边的匹配了第二个候选项（函数调用）。</p><p>　　因为多数语言的发明者都会把他们的语法设计为没有二义性的，所以一个具有二义性的语法相当于是程序中的bug。我们需要重新组织语法，确保每个输入串只有一个解析方式。如果语法分析器检测到了二义性的句子，它必须从候选项中挑选一个可行有效的。antlr默认会通过挑选第一个候选项来消除二义性。在这种情况下，语法解析器会选择将<code>f();</code>解析为左边的语法分析树。</p><p>　　二义性不仅仅会出现在语法分析中，在词法分析中有时也会出现，但是antlr都帮你将二义性消除了。antlr消除词法二义性的方法也是选择第一个（在语法声明中，第一个符合的词法规则）。我们可以看一个例子来理解：在多数的编程语言中，<code>关键字</code>和<code>标识符</code>的二义性。关键字<code>begin</code>（后面跟随一个非字母字符），也是一个标识符，所以，词法分析器可以将<code>b-e-g-i-n</code>和这两个词法规则匹配。</p><pre><code>BEGIN : &#39;begin&#39; ; //关键字ID : [a-z]+ ; //标识符</code></pre><p>　　需要记住的一点是，词法分析器会尽可能地匹配多的字符，所以，<code>beginner</code>将只会匹配为标识符，而不是关键字<code>begin</code>后面加上一个标识符<code>ner</code>。</p><p>　　有时，有些语法天生就是二义性的，无论你怎么改变它也不能改变这个事实。例如，算术运算的表达式就是具有二义性的，你可以将<code>1+2*3</code>用两种方式来解析，从左到右计算（像<code>Smalltalk</code>那样），或者像多数语言那样，按照<code>运算符优先级</code>来计算。我们将会在第五章第四节学习如何显示地声明运算符的优先级。</p><p>　　<code>C语言</code>中，存在另一种二义性，我们需要根据上下文信息，例如标识符是怎么被声明的（译者注：<a href="https://zh.wikipedia.org/wiki/%E4%B8%8A%E4%B8%8B%E6%96%87%E6%9C%89%E5%85%B3%E6%96%87%E6%B3%95" target="_blank" rel="noopener">上下文有关文法</a>）来消除它。例如这个代码片段：<code>i*j</code>，它看起来像是乘法表达式，但是，它的具体语义，还需要根据上下文信息来决定，看<code>i</code>是一个类型名称还是一个标识符。如果<code>i</code>是类型名称，那么这个代码片段就不是乘法表达式，而是声明<code>j</code>是一个类型为<code>i</code>的<code>指针</code>。我们将会在第十一章学习如何解决这些二义性。</p><p>　　语法分析器所能做的是保证输入是有效的，以及构建语法分析树，这是很重要的东西，但是，我们需要先暂时放下这部分了，因为是时候学习如何根据语法分析树来解释或者翻译输入了。</p><h2 id="2-4-通过语法分析树构建语言应用"><a href="#2-4-通过语法分析树构建语言应用" class="headerlink" title="2.4 通过语法分析树构建语言应用"></a>2.4 通过语法分析树构建语言应用</h2><p>　　为了实现一个语言应用，我们必须对每一个输入的短语或者子短语执行一些合适的代码。做这些，最简单的方式是，在语法分析器构建的语法分析树上执行这些代码。这样，我们又回到了熟悉的java的领土中，不再需要学习antlr的语法了。</p><p>　　接下来，我们会更加深入地了解一下在antlr中用来识别句子和解析语法树的数据结构和相关的类，如果你先前有良好的数据结构的基础，那么，你对下面的内容的理解会更准确。</p><p>　　在前面，我们学习到，词法分析器处理输入字符，并且将得到的token传递给语法分析器，然后语法分析器会依次检查语法的正确性，并且构建一棵语法分析树。涉及到的antlr中的类有：<code>CharStream</code>、<code>Lexer</code>、<code>Token</code>、<code>Parser</code>、<code>ParseTree</code>。连接词法分析器和语法分析器的“管道”是<code>TokenStream</code>。下图展示了这些东西是如何结合在一起的：</p><p><img src="together.png" alt=""></p><p>　　为了减少计算机的内存消耗，这些antlr数据结构会尽可能共享多的数据。上图显示，叶子节点（token）在语法分析树中是指向token流中的token的容器。token记录了该token在<code>CharStream</code>中起始位置和结束位置的索引，而不是复制一份。同时，因为我们在词法规则中设定跳过空白符，所以，并没有与空白符（索引2和4）相关的token。</p><p>　　在这个图中也说明了，<code>ParseTree</code>的子类<code>RuleNode</code>和<code>TerminalNode</code>分别代表了子树根节点和叶子节点。<code>RuleNode</code>和<code>ParseTree</code>一样，有一些相似的方法，例如<code>getChild()</code>和<code>getParent()</code>，但是，<code>RuleNode</code>并不特定于某种语法。为了更好地支持每一个节点的访问，antlr为每条规则生成一个<code>RuleNode</code>的子类。下图显示了之前那个赋值语句语法生成的特定的类，它包含了<code>StatContext</code>、<code>AssignContext</code>和<code>ExprContext</code>：</p><p><img src="context.png" alt=""></p><p>　　这些被称作<code>上下文对象</code>，因为它们记录了在识别过程中的所有上下文信息。每一个上下文对象都知道已经识别的短语的起始token和结束token，并且可以提供了对这些短语的访问。例如，<code>AssignContext</code>提供<code>ID()</code>和<code>expr()</code>方法来访问标识符节点和表达式子树。</p><p>　　提供了以上这些类型后，我们可以手动写代码来对语法分析树进行<code>深度优先遍历</code>，我们可以在我们进入或者退出某个节点时做任何我们想做的操作。例如进行表达式的计算、更新数据结构，或者产生输出。然而，我们大可不必这么麻烦，我们可以直接使用antlr自动生成的树遍历机制。</p><h2 id="2-5-语法分析树的监听器-Listener-和访问者-Visitor"><a href="#2-5-语法分析树的监听器-Listener-和访问者-Visitor" class="headerlink" title="2.5 语法分析树的监听器(Listener)和访问者(Visitor)"></a>2.5 语法分析树的监听器(Listener)和访问者(Visitor)</h2><p>　　antlr在它的运行时中提供了两种树遍历机制。默认地，antlr会生成一个<code>Listener</code>接口，对内置的<code>树遍历器</code>触发的<code>事件</code>作出反应。这些监听器和解析XML文档的<code>SAX</code>（译者注：<code>Simple API for XML</code>，一种<code>事件驱动</code>的XML解析接口规范）文档处理对象很类似。SAX的监听器可以接受像<code>startDocument()</code>和<code>endDocument()</code>这样的事件的通知。在监听器中的方法其实就是像在GUI程序的事件处理中的回调。在我们学习完Listener后，我们还会学习antlr生成的另一种符合<code>访问者模式</code>（译者注：<a href="http://www.runoob.com/design-pattern/visitor-pattern.html" target="_blank" rel="noopener">访问者模式</a>）的树遍历器。</p><h3 id="2-5-1-语法分析树的监听器-Listener"><a href="#2-5-1-语法分析树的监听器-Listener" class="headerlink" title="2.5.1 语法分析树的监听器(Listener)"></a>2.5.1 语法分析树的监听器(Listener)</h3><p>　　为了遍历语法分析树，并且触发监听器的事件，antlr的运行时中提供了<code>ParseTreeWalker</code>类。而为了实现我们的语言应用，我们可以实现<code>ParseTreeListener</code>接口，并且在每个方法中包含特定的代码。</p><p>　　antlr为每一个语法生成一个<code>ParseTreeListener</code>的子类，其中包含每一个语法规则的<code>enter</code>和<code>exit</code>方法。例如，在遍历器遇到规则<code>assign</code>的节点时，它将会触发<code>enterAssign()</code>并且给它传递<code>AssignContext</code>参数；而在遍历器遍历了<code>assign</code>所有的子节点后，它将会触发<code>exitAssign()</code>。下图展示了<code>ParseTreeWalker</code>是如何进行深度优先遍历的（用虚线表示）：</p><p><img src="ParseTreeWalker.png" alt=""></p><p>　　上图也显示了<code>ParseTreeWalker</code>是在哪里触发规则<code>assign</code>的<code>enter</code>和<code>exit</code>方法的（其他的监听方法没有显示出来）。</p><p>　　而下图则展示了<code>ParseTreeWalker</code>的完整监听器方法调用队列：</p><p><img src="listener.png" alt=""></p><p>　　监听器的好处在于，它完全是自动的，你不需要自己去写遍历器，而且监听器的方法也不要显式地访问各个节点的子节点。</p><h3 id="2-5-2-语法分析树的访问者-Visitor"><a href="#2-5-2-语法分析树的访问者-Visitor" class="headerlink" title="2.5.2 语法分析树的访问者(Visitor)"></a>2.5.2 语法分析树的访问者(Visitor)</h3><p>　　然而，在某些情况下，我们希望自己能够控制遍历的过程，显式地调用方法来访问子节点。在使用antlr生成时，加上参数<code>-visitor</code>将会生成一个<code>Visitor</code>接口，它包含了对每一个规则的访问方法。它会对语法分析树进行一些和<code>访问者模式</code>类似的操作：</p><p><img src="visitor.png" alt=""></p><p>　　上图中的粗虚线显示了语法分析树的深度优先遍历过程，细虚线表明了Visitor的方法调用队列。为了发起语法树的遍历，我们可以创建一个Visitor接口的实现，然后调用<code>visit()</code>方法。</p><pre><code>ParseTree tree = ... ; //tree是语法分析后构建的语法分析树 MyVisitor v = new MyVisitor(); v.visit(tree); </code></pre><p>　　当发现根节点时，antlr的运行时库将会调用<code>visitStat()</code>,而后，将会根据你的Visitor接口的实现，调用以子节点作为参数的<code>visit()</code>方法，继续访问子节点。或者，通过<code>visitMethod()</code>显示调用<code>visitAssign()</code>等方法。</p><p>　　antlr不鼓励我们自己去实现生成的Visitor接口，而是生成了一个带有默认实现的Visitor实现类，这样，我们就可以避免实现接口中每一个方法，而只是覆盖我们感兴趣的方法。我们将会在第七章更加详细地学习Listener和Visitor。</p><hr><blockquote><h3 id="一些术语"><a href="#一些术语" class="headerlink" title=" 一些术语 "></a><strong> 一些术语 </strong></h3></blockquote><blockquote><p>这章介绍了一些重要的形式语言学的术语:</p></blockquote><blockquote><p><code>语言</code>  语言是有效的句子的集合；句子由短语构成；短语又由子短语构成。</p></blockquote><blockquote><p><code>语法</code>  语法是语言的形式化描述，由语法规则构成，每个规则表述了子短语的结构。</p></blockquote><blockquote><p><code>语法树或解析树</code> 用来表述句子结构的数据结构，每个子树的根节点代表语法规则，叶子节点代表token。</p></blockquote><blockquote><p><code>Token</code> token是一个字符符号；通常用来表示不同种类的标记，例如标识符、操作符或者关键字。</p></blockquote><blockquote><p><code>词法分析器</code> 将输入字符串分解为token流；进行词法分析。</p></blockquote><blockquote><p><code>语法分析器</code> 语法分析器用来检查句子的有效性；antlr会生成叫做ALL(*)的自顶向下语法分析器（因为它可以将所有的输入token用做预测分析）。</p></blockquote><blockquote><p><code>递归下降语法分析器</code>  自顶向下语法分析的一种实现，每一个函数对应一条语法规则。</p></blockquote><blockquote><p><code>前瞻符号(Lookahead token)</code>  在预测分析时，语法分析器用来和每个候选项比较的token。</p></blockquote><hr><p>　　现在，我们已经对antlr的整体纲要有了一定的了解，我们学习了从字符流到语法分析树的过程中涉及的数据结构，认识了antlr运行时中的重要的几个类的名字。并且，我们刚刚对antlr的Listener和Visitor机制有了一个粗略的认识。接下来，在下一章，我们会通过一个实例来加深理解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　现在我们已经安装好了&lt;code&gt;antlr&lt;/code&gt;并且知道了怎么去构建和运行一个简单的例子，接下来我们就来了解一下纲要。在这章，我们会了解语法解析的几个重要步骤，学习一些术语，并且接触相关的数据结构。在学习的过程中，我们了解会一些antlr中重要的类，以及，ant
      
    
    </summary>
    
      <category term="Antlr" scheme="https://w-angler.com/categories/Antlr/"/>
    
    
      <category term="Antlr" scheme="https://w-angler.com/tags/Antlr/"/>
    
      <category term="Parser Generator" scheme="https://w-angler.com/tags/Parser-Generator/"/>
    
  </entry>
  
  <entry>
    <title>第一章——初识antlr</title>
    <link href="https://w-angler.com/2016/10/09/%E7%AC%AC%E4%B8%80%E7%AB%A0%E2%80%94%E2%80%94%E5%88%9D%E8%AF%86antlr/"/>
    <id>https://w-angler.com/2016/10/09/第一章——初识antlr/</id>
    <published>2016-10-09T10:16:35.000Z</published>
    <updated>2018-04-01T10:54:56.640Z</updated>
    
    <content type="html"><![CDATA[<p>　　这本书第一部分的目标是让大家对<code>antlr</code>的能力有一个直观大致的了解，并且开启探索<code>语言应用</code>的旅程。在我们对于<code>antlr</code>有了大致的了解后，我们将会在<code>第二部分</code>耐心而系统地使用一系列现实世界中的例子来学习<code>antlr</code>。当然，在开始这些之前，我们需要安装<code>antlr</code>，并且尝试运行一个<code>Hello world</code>程序来入门学习。</p><h2 id="1-1-安装antlr"><a href="#1-1-安装antlr" class="headerlink" title="1.1 安装antlr"></a>1.1 安装antlr</h2><p>　　<code>antlr</code>是使用<code>java</code>编写而成的，所以在你开始之前，你必须在你的电脑上安装<code>java</code>的运行环境（1.6或者更高的版本）。这是必需的，即使你想用<code>antlr</code>来生成别的语言写成的<code>parser</code>，例如<code>C#</code>、<code>C++</code>。（我希望在不久的将来还可以有其他的目标生成语言）。</p><hr><blockquote><h3 id="为什么这本书使用命令行环境？"><a href="#为什么这本书使用命令行环境？" class="headerlink" title="为什么这本书使用命令行环境？"></a><strong>为什么这本书使用命令行环境？</strong></h3></blockquote><blockquote><p>在这本书中，从始至终我们都会使用命令行（<code>shell</code>或者<code>cmd</code>）来运行<code>antlr</code>和构建我们的应用程序。因为每个程序员所使用的开发环境和操作系统都不一样，而操作系统的命令行接口却是我们所共有的。使用命令行也会使得我们在学习语言应用开发中的每一步变得很明确直白。在整本书中，我使用的是Mac OS X的<code>shell</code>，但是这些命令理论上也是可以在任何<code>类unix系统</code>的<code>shell</code>和<code>windows</code>上运行的。</p></blockquote><hr><p>　　安装antlr很简单，你只需要下载最新的antlr的jar文件（译者注：书中使用的是4.0版本，这里使用的4.5.3，所以如果翻译部分出现版本不一致请忽视，这个不影响），例如:<a href="http://www.antlr.org/download/antlr-4.5.3-complete.jar" target="_blank" rel="noopener">antlr-4.5.3-complete.jar</a>，然后将它放在一个合适的位置就好了。这个jar文件包含了antlr所需的一切依赖，你可以直接运行<code>antlr开发工具</code>以及编译、执行由antlr生成的识别程序（词法分析器、语法分析器等）。简单地说，antlr可以将你给定的语法转换为一个可以识别符合这个语法的句子的程序。例如，给你一个<code>json</code>的语法，antlr可以自动生成一个程序，而通过一些在antlr运行时库中用来支持运行这个程序的类，你可以很方便地识别你输入的json文本。</p><p>　　这个jar文件也包含了两个其他很有用的类库：一个精简的<a href="http://code.google.com/p/treelayout" target="_blank" rel="noopener">tree layout</a>库和<a href="http://www.stringtemplate.org" target="_blank" rel="noopener">StringTemplate</a>（一个用来生成代码或者其他结构化文本的很有用的模块引擎）。而antlr 4.0是使用antlr v3写的（译者注：编译自举，<a href="https://en.wikipedia.org/wiki/Bootstrapping_#40compilers#41" target="_blank" rel="noopener">维基百科</a>，<a href="http://www.zhihu.com/question/28513473" target="_blank" rel="noopener">编译器的自举原理是什么？</a>），所以在这个jar文件中也包含了之前版本的antlr。</p><hr><blockquote><h3 id="StringTemplate模板引擎"><a href="#StringTemplate模板引擎" class="headerlink" title="StringTemplate模板引擎"></a><strong>StringTemplate模板引擎</strong></h3></blockquote><blockquote><p>StringTemplate是一个Java编写的用来生成源代码、网页、邮件、或者其他结构化文本的模板引擎（提供了C#、Python、Ruby和Scala的接口）。StringTemplate特别擅长用来作为多个生成目标、多个网站主题的模板生成器，它也支持国际化/本地化。<a href="http://www.jguru.com" target="_blank" rel="noopener">jGuru.com</a>用它进行了多年的开发。StringTemplate也被用来生成antlr的官网，并且用它来增强antlr v3和antlr v4的代码生成能力。详情可以查看它的<a href="http://www.stringtemplate.org/about.html" target="_blank" rel="noopener">官网</a>。</p></blockquote><hr><p>　　你可以用浏览器从antlr的<a href="http://www.antlr.org" target="_blank" rel="noopener">官网</a>下载antlr，或者，你也可以使用命令行工具<code>curl</code>来获取：</p><pre><code>$ cd /usr/local/lib$ curl -O http://www.antlr.org/download/antlr-4.5.3-complete.jar</code></pre><p>　　在Unix上，<code>/usr/local/lib</code>是存储像antlr这样的文件的绝佳位置。而在Windows上，似乎没有规定哪个文件夹是专门放这个的，所以你可以直接将它存放在你的项目目录下。大多数的开发环境都会要求你将jar文件放在你的<code>语言应用</code>项目的依赖列表（译者注：例如<code>Eclipse</code>的<code>Build Path</code>）中。你也不需要修改配置脚本或者配置文件之类的——你所需要做的仅仅是确保JRE知道怎么去加载这个jar文件（译者注：如下，确保环境变量<code>CLASSPATH</code>中有这个jar文件）。</p><p>　　因为本书从始至终都是使用命令行来运行antlr，所以在此之前，你需要做一件（也是唯一的一件）繁琐的事：设置<code>CLASSPATH</code>环境变量。设置好<code>CLASSPATH</code>后，JRE就可以找到antlr工具和运行时依赖了。在Unix系统上，你可以执行以下的命令，或者直接添加到shell的<code>启动脚本</code>（译者注：<code>.bash_rc</code>或者<code>.bash.profile</code>，依shell的种类而定，也可以添加到<code>/etc/profile</code>里）。</p><pre><code>export CLASSPATH=&quot;.:/usr/local/lib/antlr-4.5.3-complete.jar:$CLASSPATH&quot; </code></pre><p>　　那个<code>.</code>，当前目录的标志，是一个很关键的地方。没有它，java的编译器和JVM会忽视当前目录下的<code>.class</code>文件。在本书中，编译、测试都是在当前目录下进行的。</p><p>　　完成这些之后，你就可以通过运行不带命令行参数的antlr工具来检查antlr是否安装成功。你可以用<code>java -jar</code>来引用jar文件，或者直接运行<code>org.antlr.v4.Tool</code>。</p><pre><code>$ java -jar /usr/local/lib/antlr-4.5.3-complete.jar    ANTLR Parser Generator  Version 4.5.3    -o ___              specify output directory where all output is generated    -lib ___            specify location of grammars, tokens files    ....$ java org.antlr.v4.Tool     ANTLR Parser Generator  Version 4.5.3    -o ___              specify output directory where all output is generated    -lib ___            specify location of grammars, tokens files    ....</code></pre><p>　　如果一直都是通过输入这么长的命令来运行antlr话，那将是一件非常痛苦的事情，所以，你最好给这些命令起一个<code>别名（alias）</code>。在书中，我会使用<code>antlr4</code>命令，你可以在unix中这样定义：</p><pre><code>alias antlr4=&#39;java -jar /usr/local/lib/antlr-4.5.3-complete.jar&#39; </code></pre><p>　　或者，你也可以将以下的脚本命令放在<code>/usr/local/bin</code>下（译者注：文件第一行的<code>#!/bin/sh</code>需要依系统而定）：</p><pre><code>#!/bin/shjava -cp &quot;/usr/local/lib/antlr-4.5.3-complete.jar:$CLASSPATH&quot; org.antlr.v4.Tool $*</code></pre><p>　　在Windows上，你可以像下面一样（假设你把jar文件放在<code>C:\libraries</code>下）：</p><pre><code>java -cp C:\libraries\antlr-4.5.3-complete.jar;%CLASSPATH% org.antlr.v4.Tool %* </code></pre><p>　　做完这些后，你就可以直接输入<code>antlr4</code>运行了。</p><pre><code>$ antlr4    ANTLR Parser Generator  Version 4.5.3    -o ___              specify output directory where all output is generated    -lib ___            specify location of grammars, tokens files    ....</code></pre><p>　　如果你能看到运行后出现的帮助信息，说明你已安装成功了，你已经准备好成为antlr老司机了。</p><h2 id="1-2-执行、测试antlr生成工具"><a href="#1-2-执行、测试antlr生成工具" class="headerlink" title="1.2 执行、测试antlr生成工具"></a>1.2 执行、测试antlr生成工具</h2><p>　　这有一个识别像<code>hello parrt</code>和<code>hello world</code>这样的句子的语法：</p><p><code>Hello.g4</code></p><pre><code>grammar Hello; //定义一个叫Hello的语法r : &#39;hello&#39; ID; //匹配关键字hello和跟随在后面的标识符ID : [a-z]+; //匹配小写字母组成的标识符WS : [ \t\r\n]+ -&gt; skip; //跳过，不解析这些字符 </code></pre><p>　　为了保持一切的整洁，我们可以把语法文件<code>Hello.g4</code>放在某个单独的文件夹中，例如<code>/tmp/test</code>。然后我们就可以运行antlr并且编译生成的结果了。</p><pre><code>$ cd /tmp/test$ #复制粘贴或者下载Hello.g4到/tmp/test$ antlr4 Hello.g4 #生成lexer和parser$ lsHello.g4 HelloLexer.java HelloParser.java Hello.tokens HelloLexer.tokens HelloBaseListener.java HelloListener.java $ javac *.java #编译antlr生成的代码</code></pre><p>　　在Hello.g4上运行antlr工具将会生成一个可执行的识别器程序（<code>HelloParser.java</code>和<code>HelloLexer.java</code>）,但是我们并没有<code>main方法</code>来触发识别器工作（我们将会在下一章学习什么是<code>lexer</code>和<code>parser</code>）。这是在一个项目开始时很容易碰到的窘境。在开发真正的语言应用之前，你将会和几个不同的简单语法打交道，所以如果可以避免为每个语法写一个<code>main方法</code>将会很nice。</p><p>　　所幸，antlr在运行时库中提供了一个具有伸缩性的测试工具<code>TestRig</code>。它能在识别器识别<code>文件输入</code>和<code>标准输入</code>的过程中呈现很多的信息。<code>TestRig</code>通过使用java的<code>反射机制</code>来调用编译后的识别器。像之前一样，你最好也给它赋予一个别名或者写在<code>shell脚本</code>或者<code>批处理文件</code>中。我之后把它叫做<code>grun</code>，当然，你也可以命名为其他的。</p><pre><code>alias grun=&#39;java org.antlr.v4.runtime.misc.TestRig&#39; </code></pre><p>　　这个测试工具使用<code>语法名称</code>、<code>起始语法规则</code>以及一些其他用来选择输出方式的选项作为参数（<code>起始语法规则</code>就像是<code>main()</code>方法）。假设我们想要打印在识别过程中构建的<code>token</code>（<code>token</code>是像关键字<code>hello</code>和变量<code>parrt</code>这样的单词），为了测试这个语法，我们可以像下面一样来运行<code>grun</code>：</p><pre><code>$ grun Hello r -tokens #开始使用TestRig测试语法Hello的r规则，以token流形式输出hello parrt #输入你需要识别的文本EOF # unix输入ctrl-D，Windows输入Ctrl+Z[@0,0:4=&#39;hello&#39;,&lt;1&gt;,1:0] #这三行是grun的输出[@1,6:10=&#39;parrt&#39;,&lt;2&gt;,1:6][@2,12:11=&#39;&lt;EOF&gt;&#39;,&lt;-1&gt;,2:0]</code></pre><p>　　输入<code>grun</code>命令，敲击换行符之后，控制台将会耐心地等待你输入<code>hello parrt</code>和一个换行符。随后，你还必须输入<code>EOF</code>来终止标准输入，否则，这个程序将会一直等你，直到天荒地老。一旦识别器读取完所有的输入，<code>TestRig</code>将会打印出所有的token（使用<code>-tokens</code>参数）。</p><p>　　输出的每一行代表一个token，它会将识别出的token的每个信息都打印了出来。例如，<code>[@1,6:10=&#39;parrt&#39;,&lt;2&gt;,1:6]</code>，它表明，这个token是第二个token（索引从0开始），token的内容是从<code>6</code>到<code>10</code>的字符（索引也是从0开始），内容是<code>parrt</code>，token类型是<code>2</code>，在<code>第1行</code>（从1开始），从<code>第6列</code>开始（索引从0开始，<code>tab</code>算做是单独的一个字符）。</p><p>　　我们也可以很容易地打印<code>Lisp风格</code>的语法解析树（译者注：<code>Lisp风格</code>，在我看来很像<code>抽象语法树</code>，括号中，起始第一个是树的根节点，之后跟随的是该节点的枝叶）：</p><pre><code>$ grun Hello r -treehello parrtEOF(r hello parrt)</code></pre><p>　　当然，我们有更直观的方式来表示识别器是如何识别输入的文本的——可视化解析树。带<code>-gui</code>参数运行TestRig，它将会创建一个类似下面的对话框：</p><p><img src="gui.png" alt=""></p><p>　　不带参数运行<code>TestRig</code>将会输出一些帮助信息：</p><pre><code>$ grunjava org.antlr.v4.runtime.misc.TestRig GrammarName startRuleName [-tokens] [-tree] [-gui] [-ps file.ps] [-encoding encodingname] [-trace] [-diagnostics] [-SLL] [input-filename(s)]Use startRuleName=&#39;tokens&#39; if GrammarName is a lexer grammar. Omitting input-filename makes rig read from stdin.</code></pre><p>　　随着我们学习的深入，我们将会多次使用这些参数，以下简短介绍一下他们的用处：</p><ul><li><code>-tokens</code> 打印token流。</li><li><code>-tree</code> 打印Lisp风格的语法解析树。</li><li><code>-gui</code> 创建一个对话框可视化显示语法解析树。</li><li><code>-ps file.ps</code> 生成一个用<code>PostScript</code>表示的可视化语法解析树，并保存在<code>file.ps</code>中。这章的语法解析树就是使用<code>-ps</code>生成的。</li><li><code>-encoding encodingname</code> 特别指定<code>TestRig</code>的输入文件的编码（如果存在本地化问题，出现乱码的话），例如，在后面的章节中，我们需要使用这个参数来解析一个使用日本编码的XML文件。</li><li><code>-trace</code> 当进入、退出每个语法规则时，打印语法规则的名称和当前token。</li><li><code>-diagnostics</code> 打开解析时的诊断信息。这个会生成一些特定情况下的诊断信息，例如，输入的文本具有二义性。</li><li><code>-SLL</code> 使用更快但稍微能力弱一些的解析策略。</li></ul><hr><p>　　现在，我们已经安装好了antlr，并且用它在一个简单的语法上试了试锋芒，让我们回过头来熟悉一下antlr的整个使用流程，在下一章，我们将会学习一些重要的<code>术语</code>，而后，我们将会尝试一个新手项目——它可以识别并且翻译整型数组。在那之后，我们将会在第四章通过一系列有趣的例子来证明antlr的强大，以及它所适用的领域。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　这本书第一部分的目标是让大家对&lt;code&gt;antlr&lt;/code&gt;的能力有一个直观大致的了解，并且开启探索&lt;code&gt;语言应用&lt;/code&gt;的旅程。在我们对于&lt;code&gt;antlr&lt;/code&gt;有了大致的了解后，我们将会在&lt;code&gt;第二部分&lt;/code&gt;耐心而系统地使
      
    
    </summary>
    
      <category term="Antlr" scheme="https://w-angler.com/categories/Antlr/"/>
    
    
      <category term="Antlr" scheme="https://w-angler.com/tags/Antlr/"/>
    
      <category term="Parser Generator" scheme="https://w-angler.com/tags/Parser-Generator/"/>
    
  </entry>
  
  <entry>
    <title>ANTLR文档（中文简体）——前言</title>
    <link href="https://w-angler.com/2016/10/09/ANTLR%E6%96%87%E6%A1%A3%EF%BC%88%E4%B8%AD%E6%96%87%E7%AE%80%E4%BD%93%EF%BC%89%E2%80%94%E2%80%94%E5%89%8D%E8%A8%80/"/>
    <id>https://w-angler.com/2016/10/09/ANTLR文档（中文简体）——前言/</id>
    <published>2016-10-09T04:31:29.000Z</published>
    <updated>2018-04-01T10:41:05.329Z</updated>
    
    <content type="html"><![CDATA[<center><h2>ANTLR文档（中文简体）</h2></center><p>　　antlr是一个用于读写、处理、执行、翻译结构化文本或者二进制文件的解析生成器。它被广泛的使用在编译语言、开发工具和框架中。通过解析特定的文法，antlr可以生成能够进行词法分析（lexer）和语法树解析（parser）的自动化程序，并且具有较强的定制性、拓展性。</p><p>　　在入坑PLT之前就接触过antlr，而这个学期的解释器构造课程又需要使用，其官方文档很全面，但是网上所能找到的中文翻译都比较粗糙，刚好大三上学期还要再刷高一点六级的分数，于是便有了自己翻译的想法，提高英语，顺便造福他人。</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>　　这是第一次翻译，估计所有的英语都已经还给老师了。</p><p>　　翻译要求<code>信、达、雅</code>，我只能说尽量以简单易懂的方式进行表述，不要出现那种翻译腔吧！</p><p>　　在翻译的过程中，有些术语用中文可能会更让人迷惑，例如<code>Token</code>，翻译为<code>令牌</code>、<code>标记</code>、<code>记号</code>都会让人很迷惑，所以，有些术语在本书的翻译过程中可能并不翻译。在这里提前让大家了解一下这些术语，便于对整本书的了解。</p><ul><li>Token：单词，记号，标记，或者其他之类的翻译，是用来表述语法分析中的最小单位的一个术语，它一般是一个字符串字面值加上一些对这个字面值的简单描述，如token出现的<code>行列号</code>、<code>token类型</code>等等。相当于英语中的一个单词，中文中的一个词语。</li><li>Lexer：词法分析器，又称扫描器，用于将我们编写的文本代码流解析为一个一个的<code>Token</code>，分析得到的<code>Token</code>以供后续语法分析使用。</li><li>Parser：语法分析器，它的作用是进行语法检查、并构建由输入的单词组成的数据结构（一般是语法树、抽象语法树（AST）等层次化的数据结构）。语法分析器需要从词法分析器中获取<code>token流</code>。</li></ul><p>　　而有些涉及到文法的二义性的问题，这个则与英语和汉语之间的差异性有关。例如在书中有一个<code>You Can’t Put Too Much Water into a Nuclear Reactor</code>的例子，用中文是很难表述出二义性的。这个我尽量结合英语的一些语法来解释一下。</p><h1 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h1><p>　　如果无意中对原文作者侵犯了著作权，本人承诺会马上删除并承担相应的责任。</p><p>　　当然，我会尽量与作者取得联系，争取他的同意。</p><p>　　本书翻译采用<code>MIT</code>协议：</p><blockquote><p>MIT License</p></blockquote><blockquote><p>Copyright (c) 2016 汪鹏程</p></blockquote><blockquote><p>Permission is hereby granted, free of charge, to any person obtaining a copy</p></blockquote><blockquote><p>of this software and associated documentation files (the “Software”), to deal</p></blockquote><blockquote><p>in the Software without restriction, including without limitation the rights</p></blockquote><blockquote><p>to use, copy, modify, merge, publish, distribute, sublicense, and/or sell</p></blockquote><blockquote><p>copies of the Software, and to permit persons to whom the Software is</p></blockquote><blockquote><p>furnished to do so, subject to the following conditions:</p></blockquote><blockquote><p>The above copyright notice and this permission notice shall be included in all</p></blockquote><blockquote><p>copies or substantial portions of the Software.</p></blockquote><blockquote><p>THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</p></blockquote><blockquote><p>IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</p></blockquote><blockquote><p>FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</p></blockquote><blockquote><p>AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</p></blockquote><blockquote><p>LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</p></blockquote><blockquote><p>OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</p></blockquote><blockquote><p>SOFTWARE.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;&lt;h2&gt;ANTLR文档（中文简体）&lt;/h2&gt;&lt;/center&gt;

&lt;p&gt;　　antlr是一个用于读写、处理、执行、翻译结构化文本或者二进制文件的解析生成器。它被广泛的使用在编译语言、开发工具和框架中。通过解析特定的文法，antlr可以生成能够进行词法分析（lexe
      
    
    </summary>
    
      <category term="Antlr" scheme="https://w-angler.com/categories/Antlr/"/>
    
    
      <category term="Antlr" scheme="https://w-angler.com/tags/Antlr/"/>
    
      <category term="Parser Generator" scheme="https://w-angler.com/tags/Parser-Generator/"/>
    
  </entry>
  
  <entry>
    <title>lambda表达式及JVM语言实现的一些思考</title>
    <link href="https://w-angler.com/2016/10/08/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8F%8AJVM%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
    <id>https://w-angler.com/2016/10/08/lambda表达式及JVM语言实现的一些思考/</id>
    <published>2016-10-07T16:17:15.000Z</published>
    <updated>2018-04-01T16:24:54.987Z</updated>
    
    <content type="html"><![CDATA[<p><code>Java 8</code>是一个激动人心的版本。</p><p>在基本类库上，JDK的很多api都进行了很大的改进，性能也有了很大的提升，特别是<code>HashMap</code>和新的<code>Time API</code>。而语法层面，应该是Java 5之后，特性增加最多的一个版本，接口的default方法、静态方法等等，还有就是，<code>lambda表达式</code>，以及引申出来的stream API、函数式接口、函数引用等。</p><p>Java王国里<code>动词</code>的地位终于有了提升。</p><hr><p><strong>注：</strong></p><p>Java王国的名词动词，这个典故来自大神<code>Steve Yegge</code>的博客：<a href="http://steve-yegge.blogspot.jp/2006/03/execution-in-kingdom-of-nouns.html" target="_blank" rel="noopener">Execution in the Kingdom of Nouns </a>，附上一篇中文翻译：<a href="https://my.oschina.net/justjavac/blog/68536" target="_blank" rel="noopener">名词王国里的死刑</a>。</p><p>暑假拜读了<code>Steve Yegge</code>的<code>《程序员的呐喊》</code>，书中也有这篇博文，读后受益匪浅。</p><hr><h1 id="Lambda-Expression"><a href="#Lambda-Expression" class="headerlink" title="Lambda Expression"></a>Lambda Expression</h1><p><code>Lambda Expression</code>，是一个<code>函数式编程（Functional Programming）</code>的概念，基于数学中的<code>λ演算（Lambda Calculus</code>）（具体概念可查看这个<a href="http://cgnail.github.io/tags/#lambda%E6%BC%94%E7%AE%97" target="_blank" rel="noopener">博客</a>，了解一下 ），在理论中，lambda表达式就是<code>λ演算</code>，而涉及到特定的某个编程语言时，可以看做是<code>匿名函数</code>（或者<code>闭包</code>）。λ演算在数学和计算机领域都有着很重要的地位，它基于很简单的几条定理，而推导出来的结论却可以完成任何可计算问题，也就是说，λ演算很简单，但却是<code>图灵完备</code>的。很多的函数式编程语言都起源于λ演算，例如<code>Haskell</code>、<code>Lisp</code>及其方言<code>Scheme</code>、<code>Clojure</code>等等。</p><p><code>λ演算</code>的<code>BNF范式</code>表达:</p><pre><code>&lt;expression&gt; ::= &lt;identifier&gt;&lt;expression&gt; ::= (λ &lt;identifier&gt; . &lt;expression&gt;)&lt;expression&gt; ::= (&lt;expression&gt; &lt;expression&gt;)</code></pre><p>例子：</p><pre><code>(lambda x . plus x x) y</code></pre><hr><h1 id="java-8中的lambda表达式"><a href="#java-8中的lambda表达式" class="headerlink" title="java 8中的lambda表达式"></a>java 8中的lambda表达式</h1><p><code>java 8</code>中加入的lambda表达式，总体来说，还不成熟，限制还很多，但同时让人感到很惊艳，因为这次不是像<code>java泛型</code>那样的<code>语法糖</code>，而是真的在<code>字节码</code>上对lambda提供了支持。在java 8出来之前，人们一直猜测，<code>Oracle</code>可能只是用一个语法糖将<code>匿名内部类</code>包装成lambda表达式，但结果却是使用java 7添加的<code>invokedynamic</code>指令，让人感受到满满的诚意（却也依然不能改变因为Oracle告Google的Android侵权留下的坏印象）。这样做的好处是，以后对lambda表达式进行改进时，可以不像泛型那样受到兼容性的影响，而且，不采取匿名内部类的方式，可以提高很多的性能（因为使用匿名内部类的话，JVM进行类加载需要花费较多的时间）。</p><p>lambda表达式带来的不仅仅是语法层面的美观，对于代码的可读性也有很大的帮助。</p><p>以一个简单的打印列表内所有元素的例子为例。</p><p>在java 8之前，需要这么写：</p><pre><code>List&lt;String&gt; list=new ArrayList&lt;&gt;();//balabala,add some items//method onefor(int i=0;i&lt;list.size();i++){    System.out.println(list.get(i));}//method twofor(String li:list){    System.out.println(li);}</code></pre><p>而加入lambda后：</p><pre><code>//method onelist.forEach(e-&gt;System.out.println(e));//method two,use function referencelist.forEach(System.out::println);//done,cool!</code></pre><p>是不是可以少很多代码，而且可读性也提高了不少？</p><p>当然，这种提升对于Python、JavaScript等语言来说可能根本不屑，但考虑到Java一直以来的臃肿和繁琐，引入函数式编程可以说是很大的一个进步了。</p><hr><h1 id="java-8的lambda表达式的局限性"><a href="#java-8的lambda表达式的局限性" class="headerlink" title="java 8的lambda表达式的局限性"></a>java 8的lambda表达式的局限性</h1><p>前面说过，java 8的lambda表达式还不成熟，还有很多的局限性。</p><ul><li>lambda表达式只适用于<code>函数式接口</code>，就是显式或者非显式添加了<code>@FunctionalInterface</code>注解，且只有<code>一个</code>非静态、非default的函数的接口（例如<code>Runnable</code>）。就是说，要想真正使用lambda表达式，你必须先有一个函数式接口（好像还是只有名词的感觉，函数依然要依赖于类），无法做到真正的匿名函数。不过好在JDK里添加了许多内置的函数式接口在包<code>java.util.function</code>下，目前来说还是可以满足开发需求的。</li><li>在lambda内访问的变量必须是<code>final</code>的，或者说语义上是<code>final</code>的，也就是说，lambda表达式必须是语义上不改变外部变量的。</li><li>过度依赖于基本类库。<code>Stream API</code>，加强版的<code>Collections Framework</code>，等等，lambda的使用，还是很依赖于类库的实现，而不是语法。</li></ul><p>总而言之，lambda表达式是一个很大的提升，但目前依然是：<code>语法跟不上脚步，靠类库硬撑</code>。</p><hr><h1 id="其他语言的lambda-表达式比较"><a href="#其他语言的lambda-表达式比较" class="headerlink" title="其他语言的lambda 表达式比较"></a>其他语言的lambda 表达式比较</h1><p>lambda表达式并不是函数式语言的专利，很多非函数式语言也加入了函数式编程的支持。</p><p><code>C#</code>：C#应该是语法特性很多、写起来特别爽的一个语言（毕竟巨硬亲儿子）。在<code>3.0</code>版本中，C#加入了对lambda的支持。它的具体实现是怎样的我不怎么清楚，但是因为<code>CLR</code>原生支持<code>delegate</code>，所以其实现应该比Java的lambda优美得多吧。C#的lambda表达式，用的比较多，应该是和linq一起使用吧（简直不要太爽）。</p><p>例子：</p><pre><code>/*items is a list*///linqvar result=from item in items             where item.property&gt;233            select item;//lambdavar result=items.Where(item=&gt;item.property&gt;233);</code></pre><p><code>C++</code>：<code>C++ 11</code>中加入了lambda表达式，但是我感觉有点鸡肋，基本都用不上，而且很复杂（可能是我太菜了）。</p><p>例子：</p><pre><code>int hhh=233;auto f=[hhh](int x){return hhh+x;};</code></pre><p><code>Python</code>：<code>Python</code>是个很优雅的语言，但是它的lambda表达式我真的很想吐槽，只是一个阉割版的：只能写一行……虽然在知乎上可以看到很多一行Python实现的各种神奇代码（链接：<a href="https://www.zhihu.com/question/37046157" target="_blank" rel="noopener">一行 Python 能实现什么丧心病狂的功能？</a>），但是平时你会去想这些trick吗？如果需要在lambda表达式中进行比较复杂的操作，就必须先写个复杂函数来进行这些操作。虽然Python有<code>函数对象</code>，但是这样设计lambda表达式真的好吗？</p><p>例子：</p><pre><code>list=[x for x in range(1,233)]for n in map(lambda x:x**2,list):    print(n)</code></pre><p><code>Groovy</code>：<code>Groovy</code>是我学习的第二个JVM上的语言，语法很像Python，和java完全兼容，动态语言和静态语言相结合的写法比单纯的动态语言要好多了（动态语言的<code>类型推导</code>是个坑啊，所以目前IDE的代码提示都做不到很智能，即使是<code>PyCharm</code>这样的）。在Groovy中，lambda表达式是以闭包的形式体现的（JavaScript天生支持的hhh）。</p><p>例子：</p><pre><code>def list=1..10list.each({x-&gt;print x})//或者list.each{    print it}</code></pre><p><strong>函数式语言的实现。</strong></p><p><code>Common Lisp</code>：这个是我学习的第一个函数式语言，一开始看着那些括号真的是让人头大，就像别人评价的，简直就像是直接在写<code>语法树</code>（呃，其实这个也算是Lisp的一个优点吧）。Lisp用的是<code>前缀表达式</code>，很像编译时生成的中间代码的<code>四元式</code>（<code>三元式</code>）。</p><p>感受一下这个语法树一般的语法：</p><pre><code>(+ 1 2 3 4)或者更像语法树的写法(+(+ (+ 1 2) 3)4)</code></pre><hr><h1 id="JVM其他语言的一些实现以及思考"><a href="#JVM其他语言的一些实现以及思考" class="headerlink" title="JVM其他语言的一些实现以及思考"></a>JVM其他语言的一些实现以及思考</h1><p>这个部分的灵感很大一部分来源于一篇博文：<a href="http://blog.takipi.com/the-dark-side-of-lambda-expressions-in-java-8/" target="_blank" rel="noopener">The Dark Side Of Lambda Expressions in Java 8</a>。虽然原文作者对于lambda表达式的看法其实是有一些错误的 （原博的评论可以看到），但对于JVM上其他语言的实现的思考却很不错。</p><blockquote></blockquote><p>The JVM was built to be language agnostic in the sense that it can execute code written in any language, as long as it can be translated into bytecode. The bytecode specification itself is fully OO, and was designed to closely match the Java language. That means that bytecode compiled from Java source will pretty much resemble it structurally.</p><blockquote></blockquote><p>But the farther away you get from Java – the more that distance grows. When you look at Scala which is a functional language, the distance between the source code and the executed bytecode is pretty big. Large amounts of synthetic classes, methods and variables are added by the compiler to get the JVM to execute the semantics and flow controls required by the language.</p><p>Java是一个完全<code>面向对象</code>的语言（抛开它的<code>原始类型</code>不谈），而<code>JVM平台</code>的<code>字节码规范</code>也是完全面向对象，这就意味着，从Java源码编译到字节码时，<code>语义</code>和<code>结构</code>上基本上是相符合的，不会有太大改变。</p><p>但是像<code>Groovy</code>这种动态语言、<code>Clojure</code>这种Lisp方言、<code>Scala</code>这种完美结合面向对象和函数式编程思想的语言……从源码到到字节码的差异是很大的，就是说，你必须用面向对象的方法来实现动态语言、函数式语言的特性，这就需要添加很多中间层来抹平这两者间的差异，也就是说需要很复杂的运行时来支持这些特性。</p><p>以Groovy为例，查看出现异常时它的栈轨。</p><p><code>test.groovy</code>:</p><pre><code>def check(String s) {    if (s.equals(&quot;&quot;)) {        throw new IllegalArgumentException()    }}def hhh=[&quot;lambda&quot;,&quot;&quot;,&quot;groovy&quot;]hhh.each{    check it}</code></pre><p>以debug模式运行的<code>栈轨</code>：</p><pre><code>&gt;groovy --debug test.groovyCaught: java.lang.IllegalArgumentExceptionjava.lang.IllegalArgumentException    at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)    at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)    at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)    at java.lang.reflect.Constructor.newInstance(Constructor.java:423)    at org.codehaus.groovy.reflection.CachedConstructor.invoke(CachedConstructor.java:83)    at org.codehaus.groovy.runtime.callsite.ConstructorSite$ConstructorSiteNoUnwrapNoCoerce.callConstructor(ConstructorSite.java:105)    at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallConstructor(CallSiteArray.java:60)    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:235)    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:239)    at test.check(test.groovy:3)    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)    at java.lang.reflect.Method.invoke(Method.java:498)    at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:93)    at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:325)    at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:384)    at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1024)    at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.callCurrent(PogoMetaClassSite.java:69)    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:166)    at test$_run_closure1.doCall(test.groovy:10)    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)    at java.lang.reflect.Method.invoke(Method.java:498)    at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:93)    at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:325)    at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:294)    at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1024)    at groovy.lang.Closure.call(Closure.java:414)    at groovy.lang.Closure.call(Closure.java:430)    at org.codehaus.groovy.runtime.DefaultGroovyMethods.each(DefaultGroovyMethods.java:2030)    at org.codehaus.groovy.runtime.DefaultGroovyMethods.each(DefaultGroovyMethods.java:2015)    at org.codehaus.groovy.runtime.DefaultGroovyMethods.each(DefaultGroovyMethods.java:2056)    at org.codehaus.groovy.runtime.dgm$162.invoke(Unknown Source)    at org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite$PojoMetaMethodSiteNoUnwrapNoCoerce.invoke(PojoMetaMethodSite.java:274)    at org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite.call(PojoMetaMethodSite.java:56)    at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:125)    at test.run(test.groovy:9)    at groovy.lang.GroovyShell.runScriptOrMainOrTestOrRunnable(GroovyShell.java:263)    at groovy.lang.GroovyShell.run(GroovyShell.java:518)    at groovy.lang.GroovyShell.run(GroovyShell.java:507)    at groovy.ui.GroovyMain.processOnce(GroovyMain.java:653)    at groovy.ui.GroovyMain.run(GroovyMain.java:384)    at groovy.ui.GroovyMain.process(GroovyMain.java:370)    at groovy.ui.GroovyMain.processArgs(GroovyMain.java:129)    at groovy.ui.GroovyMain.main(GroovyMain.java:109)    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)    at java.lang.reflect.Method.invoke(Method.java:498)    at org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:109)    at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:131)</code></pre><p>用<code>groovyc</code>命令编译<code>test.groovy</code>脚本，得到<code>test.class</code>和<code>test$_run_closure1.class</code>。再用<code>javap</code>命令进行反编译，得到以下结果：</p><pre><code>&gt;javap -p test.classCompiled from &quot;test.groovy&quot;public class test extends groovy.lang.Script {    private static org.codehaus.groovy.reflection.ClassInfo $staticClassInfo;    public static transient boolean __$stMC;    private static java.lang.ref.SoftReference $callSiteArray;    public test();    public test(groovy.lang.Binding);    public static void main(java.lang.String...);    public java.lang.Object run();    public java.lang.Object check(java.lang.String);    protected groovy.lang.MetaClass $getStaticMetaClass();    private static void $createCallSiteArray_1(java.lang.String[]);    private static org.codehaus.groovy.runtime.callsite.CallSiteArray $createCallSiteArray();    private static org.codehaus.groovy.runtime.callsite.CallSite[] $    getCallSiteArray();}&gt;javap -p test$_run_closure1.classCompiled from &quot;test.groovy&quot;public class test$_run_closure1 extends groovy.lang.Closure implements org.codehaus.groovy.runtime.GeneratedClosure {    private static org.codehaus.groovy.reflection.ClassInfo $staticClassInfo;    public static transient boolean __$stMC;    private static java.lang.ref.SoftReference $callSiteArray;    public test$_run_closure1(java.lang.Object, java.lang.Object);    public java.lang.Object doCall(java.lang.Object);    public java.lang.Object doCall();    protected groovy.lang.MetaClass $getStaticMetaClass();    private static void $createCallSiteArray_1(java.lang.String[]);    private static org.codehaus.groovy.runtime.callsite.CallSiteArray $createCallSiteArray();    private static org.codehaus.groovy.runtime.callsite.CallSite[] $getCallSiteArray();}</code></pre><p>从中我们可以看出，groovy脚本在运行时，编译成的是一个继承自<code>groovy.lang.Script</code>的类，而其中的闭包则是编译为一个继承自<code>groovy.lang.Closure</code>的内部类，运行时，通过<code>org.codehaus.groovy.tools.GroovyStarter</code>的main方法启动，然后<code>类加载器</code>加载生成的类，然后运行。</p><p>从<code>debug模式</code>的栈轨可以看出，运行一个groovy脚本，其中经历了很多层次的调用，而主要的都是<code>groovy运行时（runtime）</code>的调用，可见groovy运行时的复杂程度.</p><p>这个给我们的思考是，如果<code>JVM</code>不在字节码层面进行妥协的话，那么在<code>JVM</code>上实现的语言就必须编写很复杂的运行时环境来支持其与完全面向对象的字节码的差异。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;Java 8&lt;/code&gt;是一个激动人心的版本。&lt;/p&gt;
&lt;p&gt;在基本类库上，JDK的很多api都进行了很大的改进，性能也有了很大的提升，特别是&lt;code&gt;HashMap&lt;/code&gt;和新的&lt;code&gt;Time API&lt;/code&gt;。而语法层面，应该是Java 
      
    
    </summary>
    
      <category term="PLT" scheme="https://w-angler.com/categories/PLT/"/>
    
    
      <category term="Java" scheme="https://w-angler.com/tags/Java/"/>
    
      <category term="JVM" scheme="https://w-angler.com/tags/JVM/"/>
    
      <category term="虚拟机" scheme="https://w-angler.com/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>关于翻译Antlr文档的计划</title>
    <link href="https://w-angler.com/2016/10/07/%E5%85%B3%E4%BA%8E%E7%BF%BB%E8%AF%91Antlr%E6%96%87%E6%A1%A3%E7%9A%84%E8%AE%A1%E5%88%92/"/>
    <id>https://w-angler.com/2016/10/07/关于翻译Antlr文档的计划/</id>
    <published>2016-10-07T09:51:33.000Z</published>
    <updated>2018-04-01T10:58:41.840Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于翻译antlr文档的计划"><a href="#关于翻译antlr文档的计划" class="headerlink" title="关于翻译antlr文档的计划"></a>关于翻译antlr文档的计划</h1><p>　　<code>antlr</code>是一个用于读写、处理、执行、翻译结构化文本或者二进制文件的解析生成器。它被广泛的使用在编译语言、开发工具和框架中。通过解析特定的文法，<code>antlr</code>可以生成能够进行词法分析（<code>lexer</code>）和语法树解析（<code>parser</code>）的自动化程序，并且具有较强的定制性、拓展性。</p><p>　　在入坑<code>PLT</code>之前就接触过<code>antlr</code>，而这个学期的解释器构造课程又需要使用，其官方文档很全面，但是网上所能找到的中文翻译都比较粗糙，刚好这个学期还要再刷高一点六级的分数，于是便有了自己翻译的想法，提高英语，顺便造福他人。</p><p>　　暂时先挖坑，看能不能在六级前翻译完。</p><hr><h1 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h1><p>　　<a href="https://pragprog.com/book/tpantlr2/the-definitive-antlr-4-reference" target="_blank" rel="noopener">《The Definitive ANTLR 4 Reference》</a>一共包含四部分，十五章。</p><p>　　10月7日开始，到六级还有大约10周，一周2章，看情况顺延（懒癌）。</p><hr><p><strong>第一周</strong></p><ul><li><code>Meet ANTLR</code> ：<strong>已完成</strong>，<a href="http://w-angler.com/2016/10/09/%E7%AC%AC%E4%B8%80%E7%AB%A0%E2%80%94%E2%80%94%E5%88%9D%E8%AF%86antlr/">第一章——初识antlr</a></li><li><code>The Big Picture</code>：<strong>已完成</strong>，<a href="http://w-angler.com/2016/10/16/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E2%80%94%E2%80%94antlr%E7%BA%B2%E8%A6%81/">第二章——antlr纲要</a></li></ul><p><strong>第二周</strong></p><ul><li><code>A Starter ANTLR Project</code>：<strong>已完成</strong>，<a href="http://w-angler.com/2016/10/18/%E7%AC%AC%E4%B8%89%E7%AB%A0%E2%80%94%E2%80%94antlr%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80/">第三章——antlr小试牛刀</a></li><li><code>A Quick Tour</code>：未完成</li></ul><p><strong>第三周</strong></p><ul><li><code>Designing Grammars</code>：未完成</li><li><code>Exploring Some Real Grammars</code>：未完成</li></ul><p><strong>第四周</strong></p><ul><li><code>Decoupling Grammars from Application-Specific Code</code>：未完成</li><li><code>Building Some Real Language Applications</code>：未完成</li></ul><p><strong>第五周</strong></p><ul><li><code>Error Reporting and Recovery</code>：未完成</li><li><code>Attributes and Actions</code>：未完成</li></ul><p><strong>第六周</strong></p><ul><li><code>Altering the Parse with Semantic Predicates</code>：未完成</li><li><code>Wielding Lexical Black Magic</code>：未完成</li></ul><p><strong>第七周</strong></p><ul><li><code>Exploring the Runtime API</code>：未完成</li><li><code>Removing Direct Left Recursion</code>：未完成</li></ul><p><strong>第八周</strong></p><ul><li><code>Grammar Reference</code>：未完成</li></ul><p><strong>第九周</strong></p><ul><li>待定</li></ul><p><strong>第十周</strong></p><ul><li>待定</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关于翻译antlr文档的计划&quot;&gt;&lt;a href=&quot;#关于翻译antlr文档的计划&quot; class=&quot;headerlink&quot; title=&quot;关于翻译antlr文档的计划&quot;&gt;&lt;/a&gt;关于翻译antlr文档的计划&lt;/h1&gt;&lt;p&gt;　　&lt;code&gt;antlr&lt;/code&gt;是一
      
    
    </summary>
    
      <category term="Antlr" scheme="https://w-angler.com/categories/Antlr/"/>
    
    
      <category term="Antlr" scheme="https://w-angler.com/tags/Antlr/"/>
    
      <category term="Parser Generator" scheme="https://w-angler.com/tags/Parser-Generator/"/>
    
  </entry>
  
</feed>
